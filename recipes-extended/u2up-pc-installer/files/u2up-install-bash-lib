#!/bin/bash
#
# A u2up-yocto instalation/upgrade bash library
#
#set -xe

U2UP_INSTALL_BASH_LIB_SOURCED=yes
U2UP_CONF_DIR="/etc/u2up-conf.d"
if [ ! -d "${U2UP_CONF_DIR}" ]; then
	rm -rf $U2UP_CONF_DIR
	mkdir -p $U2UP_CONF_DIR
fi

U2UP_IDS_CONF_FILE="00-u2up_ids-conf"
U2UP_KEYMAP_CONF_FILE="10-keymap-conf"
U2UP_TARGET_DISK_CONF_FILE="20-target_disk-conf"
U2UP_TARGET_HOSTNAME_CONF_FILE="30-hostname-conf"
U2UP_TARGET_ADMIN_CONF_FILE="40-admin-conf"
U2UP_NETWORK_CONF_FILE="50-network-conf"
U2UP_INSTALL_REPO_CONF_FILE="60-install_repo-conf"

# Use common partition to download images bundle:
U2UP_IMAGES_DIR="/var/log/u2up-images"
U2UP_IMAGES_LOCAL_DIR="/var/lib/u2up-images"

U2UP_IMAGES_BUNDLE_NAME="u2up-homegw-bundle"
U2UP_IMAGES_BUNDLE_ARCHIVE=${U2UP_IMAGES_BUNDLE_NAME}.tar
U2UP_IMAGES_BUNDLE_ARCHIVE_SUM=${U2UP_IMAGES_BUNDLE_NAME}.tar.sha256

#U2UP_FS_IMAGE_ARCHIVE=u2up-homegw-image-full-cmdline
U2UP_IMAGE_ROOTFS_NAME=""
U2UP_IMAGE_ROOTFS_DTS=""
#U2UP_KERNEL_MODULES_ARCHIVE=modules
U2UP_KERNEL_IMAGE=bzImage
U2UP_INITRD_IMAGE=microcode
U2UP_EFI_FALLBACK_IMAGE=bootx64.efi

MACHINE="intel-corei7-64"

U2UP_INSTALL_ROOT_MNT="/mnt"
U2UP_TEMP_DIR="/tmp/u2up-temp"
if [ ! -d "${U2UP_TEMP_DIR}" ]; then
	rm -rf $U2UP_TEMP_DIR
	mkdir -p $U2UP_TEMP_DIR
fi
U2UP_TARGET_DISK_SFDISK_BASH=${U2UP_TEMP_DIR}/u2up_target_disk-sfdisk_bash
U2UP_TARGET_DISK_SFDISK_DUMP=${U2UP_TEMP_DIR}/u2up_target_disk-sfdisk_dump

PART_TYPE_EFI="C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
PART_TYPE_LINUX="0FC63DAF-8483-4772-8E79-3D69D8477DE4"

get_boot_label() {
	local boot_label=$1
	local boot_label_conf=
	if [ -z "${boot_label}" ]; then
		return
	fi
	boot_label_conf="/boot/loader/entries/${boot_label}.conf"
	if [ ! -f "${boot_label_conf}" ]; then
		return
	fi
	cat ${boot_label_conf} | grep title | sed 's/.*title[ ]*//g'
}

get_default_boot_label() {
	local default_boot_conf=""
	if [ ! -f "/boot/loader/loader.conf" ]; then
		return
	fi
	default_boot_conf="/boot/loader/entries/$(cat /boot/loader/loader.conf | grep "default" | sed 's/default //g').conf"
	if [ ! -f "${default_boot_conf}" ]; then
		return
	fi
	cat ${default_boot_conf} | grep title | sed 's/.*title[ ]*//g'
}

set_default_boot() {
	local new_boot_label=$1

	if [ -z "${new_boot_label}" ]; then
		return 1
	fi
	if [ ! -f "/boot/loader/entries/${new_boot_label}.conf" ]; then
		return 1
	fi
	echo "default ${new_boot_label}" > /boot/loader/loader.conf
	(( rv+=$? ))
	echo "timeout 5" >> /boot/loader/loader.conf
	(( rv+=$? ))
	if [ $rv -ne 0 ]; then
		return $rv
	fi
	return $rv
}

get_current_target_disk() {
	local TARGET_DISK_SET=""
	if [ -f "${U2UP_CONF_DIR}/${U2UP_TARGET_DISK_CONF_FILE}" ]; then
		source $U2UP_CONF_DIR/$U2UP_TARGET_DISK_CONF_FILE
		echo -n "${TARGET_DISK_SET}"
	fi
}

get_current_target_part() {
	local TARGET_PART_SET=""
	if [ -f "${U2UP_CONF_DIR}/${U2UP_TARGET_DISK_CONF_FILE}" ]; then
		source $U2UP_CONF_DIR/$U2UP_TARGET_DISK_CONF_FILE
		echo -n "${TARGET_PART_SET}"
	fi
}

get_root_label_suffix() {
	local target_disk=$1
	local target_part=$2
	if [ -n "${target_part}" ]; then
		case ${target_part} in
		${target_disk}3)
			echo "A"
			return 0
			;;
		${target_disk}4)
			echo "B"
			return 0
			;;
		esac
	fi
	return 1
}

get_root_label_from_suffix() {
	local label_suffix=$1
	if [ -n "${label_suffix}" ]; then
		case ${label_suffix} in
		A|B)
			echo -n "root${label_suffix}"
			return 0
			;;
		esac
	fi
	return 1
}

get_root_label_suffix_from_label() {
	local label=$1
	if [ -n "${label}" ]; then
		case ${label} in
		rootA)
			echo "A"
			return 0
			;;
		rootB)
			echo "B"
			return 0
			;;
		esac
	fi
	return 1
}

get_root_label() {
	local label=""
	local target_disk=$1
	local target_part=$2
	local label_suffix="$(get_root_label_suffix ${target_disk} ${target_part})"
	if [ -n "${label_suffix}" ]; then
		label="$(get_root_label_from_suffix ${label_suffix})"
		if [ -n "${label}" ]; then
			echo -n "${label}"
			return 0
		fi
	fi
	return 1
}

set_target_done_for() {
	local file=${1}
	local new_target_done=${2:-0}
	local rv=1
	if [ -z "$file" ] || [ ! -e "$file" ]; then
		return $rv
	fi
	cat ${file} | grep -v "TARGET_DONE=" > ${file}_tmp
	rv=$?
	echo "TARGET_DONE=${new_target_done}" >> ${file}_tmp
	(( rv+=$? ))
	mv ${file}_tmp ${file}
	(( rv+=$? ))
	return $rv
}

store_keymap_selection() {
	local rv=1
	local keymap=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -n "$keymap" ]; then
		loadkeys -p $keymap 2> /dev/null
		rv=$?
		if [ $rv -eq 0 ]; then
			echo "KEYMAP_SET=$keymap" > ${conf_dir}/${U2UP_KEYMAP_CONF_FILE}
			echo "TARGET_DONE=0" >> ${conf_dir}/${U2UP_KEYMAP_CONF_FILE}
		fi
	fi
	return $rv
}

enable_keymap_selection() {
	local rv=1
	local KEYMAP_SET=""
	local TARGET_DONE=0
	local new_target_done=${1:-0}
	local root_path_prefix=${2:-"/"}
	local conf_dir=${3:-${U2UP_CONF_DIR}}

	if [ "${root_path_prefix}" = "/" ]; then
		root_path_prefix=""
	fi

	if [ ! -f "${root_path_prefix}${conf_dir}/${U2UP_KEYMAP_CONF_FILE}" ]; then
		return 1
	fi
	source ${root_path_prefix}${conf_dir}/${U2UP_KEYMAP_CONF_FILE}
	if [ -n "$KEYMAP_SET" ] && [ $TARGET_DONE -eq 0 ]; then
		loadkeys $KEYMAP_SET
		rv=$?
		if [ $rv -eq 0 ]; then
			echo "KEYMAP=$KEYMAP_SET" > ${root_path_prefix}/etc/vconsole.conf
			set_target_done_for ${root_path_prefix}${conf_dir}/${U2UP_KEYMAP_CONF_FILE} ${new_target_done}
			rv=$?
		fi
	fi
	return $rv
}

store_target_disk_selection() {
	local rv=1
	local disk=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	cat ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE} | grep -v "TARGET_DISK_SET=" > ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	if [ -n "$disk" ]; then
		echo "TARGET_DISK_SET=$disk" >> ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}
	rv=$?
	return $rv
}

store_target_part_selection() {
	local rv=1
	local part=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	cat ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE} | grep -v "TARGET_PART_SET=" > ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	if [ -n "$part" ]; then
		echo "TARGET_PART_SET=$part" >> ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}
	rv=$?
	return $rv
}

store_target_partsize_selection() {
	local rv=1
	local var_target_partsz_set=""
	local var_target_partsz_current=""
	local conf_dir=${1}
	shift
	local part=$(echo $@ | sed 's/RENAMED //' | sed 's/ .*//')
	declare -i part_size=$(echo $@ | sed 's/.*://')

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ $part_size -le 0 ]; then
		return 1
	fi
	case $part in
	boot)
		var_target_partsz_set=TARGET_BOOT_PARTSZ_SET
		var_target_partsz_current=target_boot_partsz_current
		;;
	log)
		var_target_partsz_set=TARGET_LOG_PARTSZ_SET
		var_target_partsz_current=target_log_partsz_current
		;;
	rootA)
		var_target_partsz_set=TARGET_ROOTA_PARTSZ_SET
		var_target_partsz_current=target_rootA_partsz_current
		;;
	rootB)
		var_target_partsz_set=TARGET_ROOTB_PARTSZ_SET
		var_target_partsz_current=target_rootB_partsz_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE} | grep -v "${var_target_partsz_set}=" > ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	echo "${var_target_partsz_set}=$part_size" >> ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}
	rv=$?
	echo "${var_target_partsz_current}=${part_size}"
	return $rv
}

store_net_internal_iface_selection() {
	local rv=1
	local ifname=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	cat ${conf_dir}/${U2UP_NETWORK_CONF_FILE} | grep -v "NET_INTERNAL_IFNAME_SET=" > ${conf_dir}/${U2UP_NETWORK_CONF_FILE}_tmp
	if [ -n "$ifname" ]; then
		echo "NET_INTERNAL_IFNAME_SET=$ifname" >> ${conf_dir}/${U2UP_NETWORK_CONF_FILE}_tmp
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_NETWORK_CONF_FILE}_tmp ${conf_dir}/${U2UP_NETWORK_CONF_FILE}
	rv=$?
	return $rv
}

store_target_hostname_selection() {
	local rv=1
	local var_target_hostname_set=""
	local var_target_hostname_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"Hostname")
		var_target_hostname_set=TARGET_HOSTNAME_SET
		var_target_hostname_current=target_hostname_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE} | grep -v "${var_target_hostname_set}=" > ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}_tmp
	echo "${var_target_hostname_set}=$value" >> ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}
	rv=$?
	echo "${var_target_hostname_current}=${value}"
	return $rv
}

enable_target_hostname_selection() {
	local rv=1
	local TARGET_HOSTNAME_SET=""
	local TARGET_DONE=0
	local new_target_done=${1:-0}
	local root_path_prefix=${2:-"/"}
	local conf_dir=${3:-${U2UP_CONF_DIR}}

	if [ "${root_path_prefix}" = "/" ]; then
		root_path_prefix=""
	fi

	if [ ! -f "${root_path_prefix}${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}" ]; then
		return 1
	fi
	source ${root_path_prefix}${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}
	if [ -n "$TARGET_HOSTNAME_SET" ] && [ $TARGET_DONE -eq 0 ]; then
		hostnamectl set-hostname $TARGET_HOSTNAME_SET
		rv=$?
		if [ $rv -eq 0 ]; then
			set_target_done_for ${root_path_prefix}${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE} ${new_target_done}
			rv=$?
		fi
	fi
	return $rv
}

store_target_admin_selection() {
	local rv=1
	local var_target_admin_name_set=""
	local var_target_admin_name_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"Admin name")
		var_target_admin_name_set=TARGET_ADMIN_NAME_SET
		var_target_admin_name_current=target_admin_name_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE} | grep -v "${var_target_admin_name_set}=" > ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}_tmp
	echo "${var_target_admin_name_set}=$value" >> ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}
	rv=$?
	echo "${var_target_admin_name_current}=${value}"
	return $rv
}

enable_target_admin_selection() {
	local rv=1
	local TARGET_ADMIN_NAME_SET=""
	local TARGET_DONE=0
	local new_target_done=${1:-0}
	local root_path_prefix=${2:-"/"}
	local conf_dir=${3:-${U2UP_CONF_DIR}}

	if [ "${root_path_prefix}" = "/" ]; then
		root_path_prefix=""
	fi

	if [ ! -f "${root_path_prefix}${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}" ]; then
		return 1
	fi
	source ${root_path_prefix}${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}
	if [ -n "$TARGET_ADMIN_NAME_SET" ] && [ $TARGET_DONE -eq 0 ]; then
		useradd -m -c "Admin User" $TARGET_ADMIN_NAME_SET
		rv=$?
		if [ $rv -ne 0 ] && [ $rv -ne 9 ]; then
			return 1
		fi
		passwd -de $TARGET_ADMIN_NAME_SET
		rv=$?
		if [ $rv -ne 0 ]; then
			return 1
		fi
		usermod -aG wheel $TARGET_ADMIN_NAME_SET
		rv=$?
		if [ $rv -ne 0 ]; then
			return 1
		fi
		# Locking the root account and scrambling its password!
		passwd -l root
		rv=$?
		if [ $rv -ne 0 ]; then
			return 1
		fi
		usermod -p '!' root
		rv=$?
		if [ $rv -eq 0 ]; then
			set_target_done_for ${root_path_prefix}${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE} ${new_target_done}
			rv=$?
		fi
	fi
	return $rv
}

store_net_config_selection() {
	local rv=1
	local var_net_config_set=""
	local var_net_config_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"IP address/mask")
		var_net_config_set=NET_INTERNAL_ADDR_MASK_SET
		var_net_config_current=net_internal_addr_mask_current
		;;
	"IP gateway")
		var_net_config_set=NET_INTERNAL_GW_SET
		var_net_config_current=net_internal_gw_current
		;;
	"DNS")
		var_net_config_set=NET_DNS_SET
		var_net_config_current=net_dns_current
		;;
	"Domains")
		var_net_config_set=NET_DOMAINS_SET
		var_net_config_current=net_domains_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_NETWORK_CONF_FILE} | grep -v "${var_net_config_set}=" > ${conf_dir}/${U2UP_NETWORK_CONF_FILE}_tmp
	echo "${var_net_config_set}=$value" >> ${conf_dir}/${U2UP_NETWORK_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_NETWORK_CONF_FILE}_tmp ${conf_dir}/${U2UP_NETWORK_CONF_FILE}
	rv=$?
	echo "${var_net_config_current}=${value}"
	return $rv
}

enable_net_config_selection() {
	local rv=0
	local NET_INTERNAL_IFNAME_SET=""
	local NET_INTERNAL_ADDR_MASK_SET=""
	local NET_INTERNAL_GW_SET=""
	local NET_DNS_SET=""
	local NET_DOMAINS_SET=""
	local TARGET_DONE=0
	local new_target_done=${1:-0}
	local root_path_prefix=${2:-"/"}
	local conf_dir=${3:-${U2UP_CONF_DIR}}

	if [ "${root_path_prefix}" = "/" ]; then
		root_path_prefix=""
	fi

	if [ ! -f "${root_path_prefix}${conf_dir}/${U2UP_NETWORK_CONF_FILE}" ]; then
		return 1
	fi
	source ${root_path_prefix}${conf_dir}/${U2UP_NETWORK_CONF_FILE}
	if [ $TARGET_DONE -eq 0 ]; then
		if [ -n "${NET_INTERNAL_IFNAME_SET}" ] && [ -n "${NET_INTERNAL_ADDR_MASK_SET}" ] && [ -n "${NET_INTERNAL_GW_SET}" ]; then
			nmcli con add type ethernet con-name internal ifname ${NET_INTERNAL_IFNAME_SET} ip4 ${NET_INTERNAL_ADDR_MASK_SET} gw4 ${NET_INTERNAL_GW_SET}
			rv=$?
			if [ $rv -eq 0 ]; then
				nmcli con mod internal connection.zone trusted
				rv=$?
			fi
		fi
		if [ $rv -eq 0 ] && [ -n "${NET_DNS_SET}" ]; then
			nmcli con mod internal ipv4.dns "${NET_DNS_SET}"
			rv=$?
		fi
		if [ $rv -eq 0 ]; then
			set_target_done_for ${root_path_prefix}${conf_dir}/${U2UP_NETWORK_CONF_FILE} ${new_target_done}
			rv=$?
		fi
	fi
	return $rv
}

execute_net_reconfiguration() {
	local root_path_prefix=${1:-"/"}
	local conf_dir=${2:-${U2UP_CONF_DIR}}
	local NET_INTERNAL_IFNAME=""
	local NET_INTERNAL_ADDR_MASK=""
	local NET_INTERNAL_GW=""
	local NET_DNS=""
	local NET_DOMAINS=""
	local rv=0

	if [ ! -f "${root_path_prefix}${conf_dir}/${U2UP_NETWORK_CONF_FILE}" ]; then
		return 1
	fi
	source ${root_path_prefix}${conf_dir}/${U2UP_NETWORK_CONF_FILE}
	if \
		[ -z "$NET_INTERNAL_IFNAME_SET" ] || \
		[ -z "$NET_INTERNAL_ADDR_MASK_SET" ] || \
		[ -z "$NET_INTERNAL_GW_SET" ] || \
		[ -z "$NET_DNS_SET" ] || \
		[ -z "$NET_DOMAINS_SET" ];
	then
		return 1
	fi
	cat > /etc/systemd/network/10-internal-static.network << EOF
[Match]
Name=${NET_INTERNAL_IFNAME_SET}

[Network]
Address=${NET_INTERNAL_ADDR_MASK_SET}
Gateway=${NET_INTERNAL_GW_SET}
DNS=${NET_DNS_SET}
Domains=${NET_DOMAINS_SET}
EOF
	rv=$?
	return $rv
}

store_install_repo_selection() {
	local rv=1
	local var_install_repo_set=""
	local var_install_repo_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"Base URL")
		var_install_repo_set=INSTALL_REPO_BASE_URL_SET
		var_install_repo_current=install_repo_base_url_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE} | grep -v "${var_install_repo_set}=" > ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}_tmp
	echo "${var_install_repo_set}=$value" >> ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}_tmp ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}
	rv=$?
	echo "${var_install_repo_current}=${value}"
	return $rv
}

enable_install_repo_selection() {
	local rv=0
	local INSTALL_REPO_BASE_URL_SET=""
	local TARGET_DONE=0
	local new_target_done=${1:-0}
	local root_path_prefix=${2:-"/"}
	local conf_dir=${3:-${U2UP_CONF_DIR}}

	if [ "${root_path_prefix}" = "/" ]; then
		root_path_prefix=""
	fi

	if [ ! -f "${root_path_prefix}${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}" ]; then
		return 1
	fi
	source ${root_path_prefix}${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}
	if [ $TARGET_DONE -eq 0 ]; then
		if [ -n "${INSTALL_REPO_BASE_URL_SET}" ]; then
			mkdir -p ${root_path_prefix}/etc/yum.repos.d
			echo "[base-repo]" > ${root_path_prefix}/etc/yum.repos.d/base.repo
			echo "name=Base installation repository" >> ${root_path_prefix}/etc/yum.repos.d/base.repo
			echo "baseurl=${INSTALL_REPO_BASE_URL_SET}" >> ${root_path_prefix}/etc/yum.repos.d/base.repo
			echo "enabled=1" >> ${root_path_prefix}/etc/yum.repos.d/base.repo
			echo "metadata_expire=0" >> ${root_path_prefix}/etc/yum.repos.d/base.repo
			echo "gpgcheck=0" >> ${root_path_prefix}/etc/yum.repos.d/base.repo
			set_target_done_for ${root_path_prefix}${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE} ${new_target_done}
			rv=$?
		else
			rm -rf /etc/yum.repos.d
			rv=$?
		fi
	fi
	return $rv
}

prepare_u2up_upgrade_configuration() {
	local rv=0
	local conf_dir=$1
	local TARGET_DISK_SET=""
	local TARGET_PART_SET=""
	local upgrade_disk_part

	if [ -z "${conf_dir}" ]; then
		return 1
	fi
	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ ! -e "${conf_dir}/${U2UP_KEYMAP_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_KEYMAP_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_TARGET_DISK_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
		source ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}
		case ${TARGET_PART_SET} in
		${TARGET_DISK_SET}3)
			upgrade_disk_part=4
			;;
		${TARGET_DISK_SET}4)
			upgrade_disk_part=3
			;;
		esac
		store_target_part_selection ${TARGET_DISK_SET}${upgrade_disk_part} ${conf_dir}
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_TARGET_HOSTNAME_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_TARGET_ADMIN_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_NETWORK_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_NETWORK_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_INSTALL_REPO_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	return $rv
}

check_create_filesystems() {
	local TARGET_DISK_SET=$1
	local TARGET_PART_SET=$2
	local fstype=""
	local msg=""
	local rv=0

	if [ $rv -eq 0 ] && [ -z "$TARGET_DISK_SET" ]; then
		msg="Target disk not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$TARGET_PART_SET" ]; then
		msg="Target disk paritition not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		# Installation partition:
		echo "Allways re-create EXT4 filesystem on installation partition /dev/$TARGET_PART_SET:" >&2
		umount -f $U2UP_INSTALL_ROOT_MNT >&2
		mkfs.ext4 -F /dev/$TARGET_PART_SET >&2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to re-create EXT4 filesystem on installation partition /dev/$TARGET_PART_SET!"
#		else
#			echo -e "OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		# Boot partition:
		echo "Check / re-create VFAT filesystem on \"boot\" partition /dev/${TARGET_DISK_SET}1:" >&2
		fstype="$(lsblk -fr /dev/${TARGET_DISK_SET}1 | grep -v "NAME" | sed 's/[a-z,0-9]* //' | sed 's/ .*//')"
		if [ -z "$fstype" ] || [ "$fstype" != "vfat" ]; then
#			echo "Recreate:" >&2
			mkfs.vfat -F /dev/${TARGET_DISK_SET}1 >&2
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to check / re-create VFAT filesystem on \"boot\" partition /dev/${TARGET_DISK_SET}1!"
#			else
#				echo -e "Re-create OK!\n" >&2
			fi
#		else
#			echo -e "Check OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		# Log partition:
		echo "Check / re-create EXT4 filesystem on \"log\" partition /dev/${TARGET_DISK_SET}2:" >&2
		fstype="$(lsblk -fr /dev/${TARGET_DISK_SET}2 | grep -v "NAME" | sed 's/[a-z,0-9]* //' | sed 's/ .*//')"
		if [ -z "$fstype" ] || [ "$fstype" != "ext4" ]; then
#			echo "Recreate:" >&2
			mkfs.ext4 -F /dev/${TARGET_DISK_SET}2 >&2
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to check / re-create EXT4 filesystem on \"log\" partition /dev/${TARGET_DISK_SET}2!"
#			else
#				echo -e "Re-create OK!\n" >&2
			fi
#		else
#			echo -e "Check OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		# RootA partition:
		echo "Check / re-create EXT4 filesystem on \"rootA\" partition /dev/${TARGET_DISK_SET}3:" >&2
		fstype="$(lsblk -fr /dev/${TARGET_DISK_SET}3 | grep -v "NAME" | sed 's/[a-z,0-9]* //' | sed 's/ .*//')"
		if [ -z "$fstype" ] || [ "$fstype" != "ext4" ]; then
#			echo "Recreate:" >&2
			mkfs.ext4 -F /dev/${TARGET_DISK_SET}3 >&2
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to check / re-create EXT4 filesystem on \"rootA\" partition /dev/${TARGET_DISK_SET}3!"
#			else
#				echo -e "Re-create OK!\n" >&2
			fi
#		else
#			echo -e "Check OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		# RootB partition:
		echo "Check / re-create EXT4 filesystem on \"rootB\" partition /dev/${TARGET_DISK_SET}4:" >&2
		fstype="$(lsblk -fr /dev/${TARGET_DISK_SET}4 | grep -v "NAME" | sed 's/[a-z,0-9]* //' | sed 's/ .*//')"
		if [ -z "$fstype" ] || [ "$fstype" != "ext4" ]; then
#			echo "Recreate:" >&2
			mkfs.ext4 -F /dev/${TARGET_DISK_SET}4 >&2
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to check / re-create EXT4 filesystem on \"rootB\" partition /dev/${TARGET_DISK_SET}4!"
#			else
#				echo -e "Re-create OK!\n" >&2
			fi
#		else
#			echo -e "Check OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		msg="Checking / re-creating filesystems successfully finished!"
	fi

	echo "${msg}" >&2
	return $rv
}

check_images_bundle_initial_content() {
	local msg=""
	local rv=0

	cd ${U2UP_IMAGES_DIR} >&2
	ln -sf ${U2UP_IMAGES_BUNDLE_ARCHIVE} $(cat ${U2UP_IMAGES_BUNDLE_ARCHIVE_SUM} | sed -e 's%^.* %%g')
	sha256sum -c ${U2UP_IMAGES_BUNDLE_ARCHIVE_SUM}
	rv=$?
	if [ $rv -ne 0 ]; then
		msg="Images bundle checksum mismatch!"
	fi
	cd - >&2
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_IDS_CONF_FILE} > /dev/null
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_IDS_CONF_FILE}!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		U2UP_IMAGE_ROOTFS_NAME=$(tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IDS_CONF_FILE} 2> /dev/null | grep U2UP_ROOTFS_NAME | sed 's/U2UP_ROOTFS_NAME\=//')
		if [ -z "${U2UP_IMAGE_ROOTFS_NAME}" ]; then
			msg="Images bundle installation rootfs archive name not set!"
			rv=1
		fi
	fi
	if [ $rv -eq 0 ]; then
		U2UP_IMAGE_ROOTFS_DTS=$(tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IDS_CONF_FILE} 2> /dev/null | grep U2UP_ROOTFS_DTS | sed 's/U2UP_ROOTFS_DTS\=//')
		if [ -z "${U2UP_IMAGE_ROOTFS_DTS}" ]; then
			msg="Images bundle installation rootfs archive Date-TimeStamp not set!"
			rv=1
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz!"
		fi
	fi
	if [ $rv -ne 0 ]; then
		U2UP_IMAGE_ROOTFS_NAME=""
		U2UP_IMAGE_ROOTFS_DTS=""
		echo "${msg}" >&2
	fi
	return $rv
}

mount_installation_filesystem() {
	local TARGET_DISK_SET=$1
	local TARGET_PART_SET=$2
	local root_part_suffix=$3
	local msg=""
	local rv=0

	echo "Mounting installation partition filesystem..." >&2
	if [ $rv -eq 0 ] && [ -z "$TARGET_DISK_SET" ]; then
		msg="Target disk not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$TARGET_PART_SET" ]; then
		msg="Target disk paritition not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$root_part_suffix" ]; then
		msg="Target root_part_suffix not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		umount -f $U2UP_INSTALL_ROOT_MNT >&2
		mount /dev/$TARGET_PART_SET $U2UP_INSTALL_ROOT_MNT >&2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount installation partition filesystem (${TARGET_PART_SET} - root${root_part_suffix})!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		msg="Mounting installation partition filesystem (${TARGET_PART_SET} - root${root_part_suffix}) successfully finished!"
	fi

	echo "${msg}" >&2
	return $rv
}

extract_rootfs_from_images_bundle() {
	local TARGET_DISK_SET=$1
	local TARGET_PART_SET=$2
	local root_part_suffix=$3
	local msg=""
	local rv=0

	echo "Extracting root filesystem archive..." >&2
	if [ $rv -eq 0 ] && [ -z "$TARGET_DISK_SET" ]; then
		msg="Target disk not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$TARGET_PART_SET" ]; then
		msg="Target disk paritition not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$root_part_suffix" ]; then
		msg="Target root_part_suffix not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz | tar xz -C $U2UP_INSTALL_ROOT_MNT >&2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to extract root filesystem archive!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		msg="Extracting root filesystem archive successfully finished!"
	fi

	echo "${msg}" >&2
	return $rv
}

update_filesystem_chrooted() {
	local msg=""
	local rv=0

	echo "Updating installed system (chrooted)..." >&2
	if [ $rv -eq 0 ]; then
		mount -o bind /dev ${U2UP_INSTALL_ROOT_MNT}/dev
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /dev!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		mount -o bind /dev/shm ${U2UP_INSTALL_ROOT_MNT}/dev/shm
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /dev/shm!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		mount -o bind /proc ${U2UP_INSTALL_ROOT_MNT}/proc
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /proc!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		mount -o bind /sys ${U2UP_INSTALL_ROOT_MNT}/sys
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /sys!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		if [ -x "${HOME}/u2up-update-chrooted.sh" ]; then
			echo "WARNING! Using local (chrooted) script!" >&2
			cp -pf ${U2UP_INSTALL_ROOT_MNT}/usr/bin/u2up-update-chrooted.sh ${U2UP_INSTALL_ROOT_MNT}/usr/bin/u2up-update-chrooted.sh_orig
			cp -f ${HOME}/u2up-update-chrooted.sh ${U2UP_INSTALL_ROOT_MNT}/usr/bin/u2up-update-chrooted.sh
		fi
		if [ -f "${HOME}/u2up-install-bash-lib" ]; then
			echo "WARNING! Using local (bash-lib) script!" >&2
			cp -pf ${U2UP_INSTALL_ROOT_MNT}/lib/u2up/u2up-install-bash-lib ${U2UP_INSTALL_ROOT_MNT}/lib/u2up/u2up-install-bash-lib_orig
			cp -f ${HOME}/u2up-install-bash-lib ${U2UP_INSTALL_ROOT_MNT}/lib/u2up/u2up-install-bash-lib
		fi
		chroot ${U2UP_INSTALL_ROOT_MNT} /usr/bin/u2up-update-chrooted.sh
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed executing (chrooted) script!"
		fi
	fi
	umount ${U2UP_INSTALL_ROOT_MNT}/sys
	umount ${U2UP_INSTALL_ROOT_MNT}/proc
	umount ${U2UP_INSTALL_ROOT_MNT}/dev/shm
	umount ${U2UP_INSTALL_ROOT_MNT}/dev
	# Mounted explicitly in chrooted env but unmounted here!
	umount ${U2UP_INSTALL_ROOT_MNT}/boot
	umount ${U2UP_INSTALL_ROOT_MNT}/var/volatile/log
	if [ $rv -ne 0 ]; then
		echo "${msg}" >&2
		echo "Failed to update installation system (chrooted)!" >&2
	else
		echo "Successfully updated installation system (chrooted)!" >&2
	fi

	return $rv 
}

check_images_bundle_all_content() {
	local msg=""
	local rv=0

	if [ -f "${U2UP_IMAGES_LOCAL_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE}" ]; then
		mv ${U2UP_IMAGES_LOCAL_DIR}/* ${U2UP_IMAGES_DIR}/
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to move local images bundle to common location!"
		fi
	fi
	if [ $rv -eq 0 ] && [ ! -f "${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE}" ]; then
		msg="Images bundle not available!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		cd ${U2UP_IMAGES_DIR} >&2
		ln -sf ${U2UP_IMAGES_BUNDLE_ARCHIVE} $(cat ${U2UP_IMAGES_BUNDLE_ARCHIVE_SUM} | sed -e 's%^.* %%g')
		sha256sum -c ${U2UP_IMAGES_BUNDLE_ARCHIVE_SUM}
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle checksum mismatch!"
		fi
		cd - >&2
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_IDS_CONF_FILE} 2> /dev/null
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_IDS_CONF_FILE}!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		U2UP_IMAGE_ROOTFS_NAME=$(tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IDS_CONF_FILE} 2> /dev/null | grep U2UP_ROOTFS_NAME | sed 's/U2UP_ROOTFS_NAME\=//')
		if [ -z "${U2UP_IMAGE_ROOTFS_NAME}" ]; then
			msg="Images bundle installation rootfs archive name not set!"
			rv=1
		fi
	fi
	if [ $rv -eq 0 ]; then
		U2UP_IMAGE_ROOTFS_DTS=$(tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IDS_CONF_FILE} 2> /dev/null | grep U2UP_ROOTFS_DTS | sed 's/U2UP_ROOTFS_DTS\=//')
		if [ -z "${U2UP_IMAGE_ROOTFS_DTS}" ]; then
			msg="Images bundle installation rootfs archive Date-TimeStamp not set!"
			rv=1
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_KERNEL_IMAGE}-${MACHINE}.bin
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_KERNEL_IMAGE}-${MACHINE}.bin!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_INITRD_IMAGE}.cpio
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_INITRD_IMAGE}.cpio!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} systemd-${U2UP_EFI_FALLBACK_IMAGE}
		rv=$?
		if [ $rv -ne 0 ]; then
			masg="Images bundle not containing: systemd-${U2UP_EFI_FALLBACK_IMAGE}!"
		fi
	fi
	if [ $rv -ne 0 ]; then
		U2UP_IMAGE_ROOTFS_NAME=""
		U2UP_IMAGE_ROOTFS_DTS=""
		echo "${msg}" >&2
	fi
	return $rv
}

extract_remaining_from_images_bundle() {
	local root_part_suffix=$1
	local msg=""
	local rv=0

	if [ $rv -eq 0 ] && [ -z "$root_part_suffix" ]; then
		msg="Target root_part_suffix not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		echo "Extracting U2UP_IDS..." >&2
		tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} --overwrite -C ${U2UP_CONF_DIR} ${U2UP_IDS_CONF_FILE} >&2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to extract U2UP_IDS!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Extracting installation boot images..." >&2
		mkdir -p /boot/EFI/BOOT
		mkdir -p /boot/loader/entries
		tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} --no-same-owner --no-same-permissions -C /boot ${U2UP_KERNEL_IMAGE}-${MACHINE}.bin >&2
		((rv+=$?))
		mv /boot/${U2UP_KERNEL_IMAGE}-${MACHINE}.bin /boot/bzImage${root_part_suffix} >&2
		((rv+=$?))
		tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} --no-same-owner --no-same-permissions -C /boot ${U2UP_INITRD_IMAGE}.cpio >&2
		((rv+=$?))
		mv /boot/${U2UP_INITRD_IMAGE}.cpio /boot/microcode${root_part_suffix}.cpio >&2
		((rv+=$?))
		if [ ! -f "/boot/EFI/BOOT/bootx64.efi" ]; then
			tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} --no-same-owner --no-same-permissions -C /boot/EFI/BOOT systemd-${U2UP_EFI_FALLBACK_IMAGE} >&2
			((rv+=$?))
			mv /boot/EFI/BOOT/systemd-${U2UP_EFI_FALLBACK_IMAGE} /boot/EFI/BOOT/${U2UP_EFI_FALLBACK_IMAGE} >&2
			((rv+=$?))
		fi
		if [ $rv -ne 0 ]; then
			msg="Failed to extract installation boot images!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		msg="Extracting installation images successfully finished!"
	fi

	echo "${msg}" >&2
	return $rv
}


populate_u2up_images_bundle() {
	local root_path_prefix=${1:-${U2UP_INSTALL_ROOT_MNT}}
	local images_dir=${2:-${U2UP_IMAGES_DIR}}
	local images_name=${3:-${U2UP_IMAGES_BUNDLE_NAME}}
	local rv=0

	if [ ! -d "${images_dir}" ]; then
		return 1
	fi
	if [ -z "$root_path_prefix" ]; then
		return 1
	fi
	rm -rf ${root_path_prefix}${images_dir}
	mkdir -p ${root_path_prefix}${images_dir}
	cp -pf ${images_dir}/${images_name}* ${root_path_prefix}${images_dir}/
	rv=$?
	return $rv
}

populate_u2up_configurations() {
	local root_path_prefix=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}
	local file=""
	local rv=0

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "$root_path_prefix" ]; then
		return 1
	fi
	rm -rf ${root_path_prefix}${U2UP_CONF_DIR}
	mkdir -p $(dirname ${root_path_prefix}${U2UP_CONF_DIR})
	cp -a ${conf_dir} ${root_path_prefix}${U2UP_CONF_DIR}
	rv=$?
	if [ $rv -eq 0 ]; then
		for file in $(ls ${root_path_prefix}${U2UP_CONF_DIR}); do
			set_target_done_for ${root_path_prefix}${U2UP_CONF_DIR}/${file} 0
			rv=$?
		done
	fi
	return $rv
}

#
# Finalize configuration during the first boot.
# (used in "u2up-pre-config.sh")
#
evaluate_u2up_configurations() {
#set -x
	local root_path_prefix="/"
	local file=""
	local rv=1
	if [ ! -d "${root_path_prefix}${U2UP_CONF_DIR}" ]; then
		return $rv
	fi
	rv=0
	for file in $(ls ${root_path_prefix}${U2UP_CONF_DIR}); do
		case $file in
		${U2UP_KEYMAP_CONF_FILE})
			enable_keymap_selection 1 ${root_path_prefix}
			rv=$?
			;;
		${U2UP_TARGET_DISK_CONF_FILE})
			;;
		${U2UP_TARGET_HOSTNAME_CONF_FILE})
			enable_target_hostname_selection 1 ${root_path_prefix}
			rv=$?
			;;
		${U2UP_TARGET_ADMIN_CONF_FILE})
			enable_target_admin_selection 1 ${root_path_prefix}
			rv=$?
			;;
		${U2UP_NETWORK_CONF_FILE})
			enable_net_config_selection 1 ${root_path_prefix}
			rv=$?
			;;
		${U2UP_INSTALL_REPO_CONF_FILE})
			enable_install_repo_selection 1 ${root_path_prefix}
			rv=$?
			;;
		esac
	done
	return $rv
}

