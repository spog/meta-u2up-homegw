#!/bin/bash
#
# A u2up-yocto instalation/upgrade bash library
#
#set -xe

U2UP_INSTALL_BASH_LIB_SOURCED=yes

############################
#                          #
# Common U2UP definitions! #
#                          #
############################
U2UP_CONF_DIR="/etc/u2up-conf.d"
if [ ! -d "${U2UP_CONF_DIR}" ]; then
	rm -rf $U2UP_CONF_DIR
	mkdir -p $U2UP_CONF_DIR
fi

U2UP_IDS_CONF_FILE="00-u2up_ids-conf"
U2UP_KEYMAP_CONF_FILE="10-keymap-conf"
U2UP_TARGET_DISK_CONF_FILE="20-target_disk-conf"
U2UP_TARGET_HOSTNAME_CONF_FILE="30-hostname-conf"
U2UP_TARGET_ADMIN_CONF_FILE="40-admin-conf"
U2UP_NETWORK_EXTERNAL_CONF_FILE="50-network_external-conf"
U2UP_NETWORK_INTERNAL_CONF_FILE="60-network_internal-conf"
U2UP_INSTALL_REPO_CONF_FILE="70-install_repo-conf"

# Use common partition to download images bundle:
U2UP_IMAGES_DIR="/var/log/u2up-images"
U2UP_IMAGES_LOCAL_DIR="/var/lib/u2up-images"

U2UP_IMAGES_BUNDLE_NAME="u2up-homegw-bundle"
U2UP_IMAGES_BUNDLE_ARCHIVE=${U2UP_IMAGES_BUNDLE_NAME}.tar
U2UP_IMAGES_BUNDLE_ARCHIVE_SUM=${U2UP_IMAGES_BUNDLE_NAME}.tar.sha256

#U2UP_FS_IMAGE_ARCHIVE=u2up-homegw-image-full-cmdline
U2UP_IMAGE_ROOTFS_NAME=""
U2UP_IMAGE_ROOTFS_DATETIME=""
#U2UP_KERNEL_MODULES_ARCHIVE=modules
U2UP_KERNEL_IMAGE=bzImage
U2UP_INITRD_IMAGE=microcode
U2UP_EFI_FALLBACK_IMAGE=bootx64.efi

MACHINE="intel-corei7-64"

U2UP_TMP_BOOT_DIR="/tmp/boot"
U2UP_INSTALL_ROOT_MNT="/mnt"
U2UP_TMP_SRV_DIR="/tmp/srv"
U2UP_TEMP_DIR="/tmp/u2up-temp"
if [ ! -d "${U2UP_TEMP_DIR}" ]; then
	rm -rf $U2UP_TEMP_DIR
	mkdir -p $U2UP_TEMP_DIR
fi
U2UP_TARGET_DISK_SFDISK_BASH=${U2UP_TEMP_DIR}/u2up_target_disk-sfdisk_bash
U2UP_TARGET_DISK_SFDISK_DUMP=${U2UP_TEMP_DIR}/u2up_target_disk-sfdisk_dump

PART_TYPE_EFI="C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
PART_TYPE_LINUX="0FC63DAF-8483-4772-8E79-3D69D8477DE4"

######################################
#                                    #
# U2UP target ROOT helper functions! #
#                                    #
######################################
get_current_target_disk() {
	if [ -f "${U2UP_CONF_DIR}/${U2UP_TARGET_DISK_CONF_FILE}" ]; then
		source $U2UP_CONF_DIR/$U2UP_TARGET_DISK_CONF_FILE
		echo -n "${u2up_TARGET_DISK}"
	fi
}

get_current_target_part() {
	if [ -f "${U2UP_CONF_DIR}/${U2UP_TARGET_DISK_CONF_FILE}" ]; then
		source $U2UP_CONF_DIR/$U2UP_TARGET_DISK_CONF_FILE
		echo -n "${u2up_TARGET_PART}"
	fi
}

get_root_label_suffix() {
	local target_disk=$1
	local target_part=$2
	if [ -n "${target_part}" ]; then
		case ${target_part} in
		${target_disk}3)
			echo "A"
			return 0
			;;
		${target_disk}4)
			echo "B"
			return 0
			;;
		esac
	fi
	return 1
}

get_root_label_from_suffix() {
	local label_suffix=$1
	if [ -n "${label_suffix}" ]; then
		case ${label_suffix} in
		A|B)
			echo -n "root${label_suffix}"
			return 0
			;;
		esac
	fi
	return 1
}

get_root_label_suffix_from_label() {
	local label=$1
	if [ -n "${label}" ]; then
		case ${label} in
		rootA)
			echo "A"
			return 0
			;;
		rootB)
			echo "B"
			return 0
			;;
		esac
	fi
	return 1
}

get_root_label() {
	local label=""
	local target_disk=$1
	local target_part=$2
	local label_suffix="$(get_root_label_suffix ${target_disk} ${target_part})"
	if [ -n "${label_suffix}" ]; then
		label="$(get_root_label_from_suffix ${label_suffix})"
		if [ -n "${label}" ]; then
			echo -n "${label}"
			return 0
		fi
	fi
	return 1
}

#set_target_done_for() {
#	local file=${1}
#	local new_target_done=${2:-0}
#	local rv=1
#	if [ -z "$file" ] || [ ! -e "$file" ]; then
#		return $rv
#	fi
#	cat ${file} | grep -v "TARGET_DONE=" > ${file}_tmp
#	rv=$?
#	echo "TARGET_DONE=${new_target_done}" >> ${file}_tmp
#	(( rv+=$? ))
#	mv ${file}_tmp ${file}
#	(( rv+=$? ))
#	return $rv
#}

######################################
#                                    #
# U2UP target BOOT helper functions! #
#                                    #
######################################
get_boot_label() {
	local boot_label=$1
	local boot_label_conf=
	if [ -z "${boot_label}" ]; then
		return
	fi
	boot_label_conf="${U2UP_TMP_BOOT_DIR}/loader/entries/${boot_label}.conf"
	if [ ! -f "${boot_label_conf}" ]; then
		return
	fi
	cat ${boot_label_conf} | grep title | sed 's/.*title[ ]*//g'
}

get_default_boot_label() {
	local default_boot_conf=""
	local target_disk=$1

	if [ -z "${target_disk}" ]; then
		return
	fi
	umount -f ${U2UP_TMP_BOOT_DIR} 2> /dev/null
	mkdir -p ${U2UP_TMP_BOOT_DIR}
	mount -t vfat -o umask=0077 /dev/${target_disk}1 ${U2UP_TMP_BOOT_DIR} >&2
	if [ $? -ne 0 ]; then
		echo "Failed to mount \"${U2UP_TMP_BOOT_DIR}\"!" >&2
		return
	fi
	echo "Successfully mounted \"${U2UP_TMP_BOOT_DIR}\"!" >&2
	if [ ! -f "${U2UP_TMP_BOOT_DIR}/loader/loader.conf" ]; then
		return
	fi
	default_boot_conf="${U2UP_TMP_BOOT_DIR}/loader/entries/$(cat ${U2UP_TMP_BOOT_DIR}/loader/loader.conf | grep "default" | sed 's/default //g').conf"
	if [ ! -f "${default_boot_conf}" ]; then
		return
	fi
	cat ${default_boot_conf} | grep title | sed 's/.*title[ ]*//g'
}

set_default_boot() {
	local rv=0
	local new_boot_label=$1

	if [ -z "${new_boot_label}" ]; then
		return 1
	fi
	if [ ! -f "${U2UP_TMP_BOOT_DIR}/loader/entries/${new_boot_label}.conf" ]; then
		return 1
	fi
	echo "default ${new_boot_label}" > ${U2UP_TMP_BOOT_DIR}/loader/loader.conf
	(( rv+=$? ))
	echo "timeout 5" >> ${U2UP_TMP_BOOT_DIR}/loader/loader.conf
	(( rv+=$? ))
	return $rv
}

create_new_boot() {
	local rv=0
	local root_part_label=$1
	local root_part_label_suffix=$2
	local root_part_uuid=$3

	if [ -z "${root_part_label}" ] || [ -z "${root_part_label_suffix}" ] || [ -z "${root_part_uuid}" ]; then
		return 1
	fi
	if [ ! -f "${U2UP_CONF_DIR}/${U2UP_IDS_CONF_FILE}" ]; then
		echo "Program terminated (missing: ${U2UP_CONF_DIR}/${U2UP_IDS_CONF_FILE})!" >&2
		return 1
	fi
	source ${U2UP_CONF_DIR}/${U2UP_IDS_CONF_FILE}
	rv=$?
	echo "title ${root_part_label} (${u2up_ROOTFS_DATETIME})" > ${U2UP_TMP_BOOT_DIR}/loader/entries/${root_part_label}.conf
	((rv+=$?))
	echo "linux /bzImage${root_part_label_suffix}" >> ${U2UP_TMP_BOOT_DIR}/loader/entries/${root_part_label}.conf
	((rv+=$?))
	echo "options label=${root_part_label} root=PARTUUID=${root_part_uuid} rootwait rootfstype=ext4 console=tty0 ttyprintk.tioccons=1" >> ${U2UP_TMP_BOOT_DIR}/loader/entries/${root_part_label}.conf
	((rv+=$?))
	echo "initrd /microcode${root_part_label_suffix}.cpio" >> ${U2UP_TMP_BOOT_DIR}/loader/entries/${root_part_label}.conf
	((rv+=$?))
	return $rv
}

############################################
#                                          #
# CHECK functions for U2UP configurations! #
#                                          #
############################################
check_net_external_ifname_set() {
	local conf_dir=${1}

	if [ -f "${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}" ]; then
		source ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}
	else
		u2up_NET_EXTERNAL_IFNAME=""
	fi
	if [ -z "$u2up_NET_EXTERNAL_IFNAME" ]; then
		return 1
	fi
}

check_net_internal_ifname_set() {
	local conf_dir=${1}

	if [ -f "${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}" ]; then
		source ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}
	else
		u2up_NET_INTERNAL_IFNAME=""
	fi
	if [ -z "$u2up_NET_INTERNAL_IFNAME" ]; then
		return 1
	fi
}

###########################################
#                                         #
# SAVE functions for U2UP configurations! #
#                                         #
###########################################
save_u2up_keymap_selection() {
	local rv=1
	local keymap=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -n "$keymap" ]; then
		loadkeys -p $keymap 2> /dev/null
		rv=$?
		if [ $rv -eq 0 ]; then
			echo "local u2up_KEYMAP=$keymap" > ${conf_dir}/${U2UP_KEYMAP_CONF_FILE}
		fi
	fi
	return $rv
}

save_u2up_target_disk_selection() {
	local rv=1
	local disk=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	cat ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE} | grep -v "u2up_TARGET_DISK=" > ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	if [ -n "$disk" ]; then
		echo "local u2up_TARGET_DISK=$disk" >> ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}
	rv=$?
	return $rv
}

save_u2up_target_part_selection() {
	local rv=1
	local part=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	cat ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE} | grep -v "u2up_TARGET_PART=" > ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	if [ -n "$part" ]; then
		echo "local u2up_TARGET_PART=$part" >> ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}
	rv=$?
	return $rv
}

save_u2up_target_partsize_selection() {
	local rv=1
	local var_target_partsz_set=""
	local var_target_partsz_current=""
	local conf_dir=${1}
	shift
	local part=$(echo $@ | sed 's/RENAMED //' | sed 's/ .*//')
	declare -i part_size=$(echo $@ | sed 's/.*://')

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ $part_size -le 0 ]; then
		return 1
	fi
	case $part in
	boot)
		var_target_partsz_set=u2up_TARGET_BOOT_PARTSZ
		var_target_partsz_current=target_boot_partsz_current
		;;
	log)
		var_target_partsz_set=u2up_TARGET_LOG_PARTSZ
		var_target_partsz_current=target_log_partsz_current
		;;
	rootA)
		var_target_partsz_set=u2up_TARGET_ROOTA_PARTSZ
		var_target_partsz_current=target_rootA_partsz_current
		;;
	rootB)
		var_target_partsz_set=u2up_TARGET_ROOTB_PARTSZ
		var_target_partsz_current=target_rootB_partsz_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE} | grep -v "${var_target_partsz_set}=" > ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	echo "local ${var_target_partsz_set}=$part_size" >> ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}
	rv=$?
	echo "${var_target_partsz_current}=${part_size}"
	return $rv
}

save_u2up_net_external_iface_selection() {
	local rv=0
	local ifname=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	cat ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE} | grep -v "u2up_NET_EXTERNAL_IFNAME=" > ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp
	if [ -n "$ifname" ]; then
		if [ "$ifname" != "none" ]; then
			echo "local u2up_NET_EXTERNAL_IFNAME=$ifname" >> ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp
		else
			echo "local u2up_NET_EXTERNAL_IFNAME=" >> ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp
		fi
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}
	rv=$?
	return $rv
}

save_u2up_net_external_mac_selection() {
	local rv=0
	local mac=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	cat ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE} | grep -v "u2up_NET_EXTERNAL_MAC_ADDR=" > ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp
	if [ -n "$mac" ]; then
		if [ "$mac" != "-" ]; then
			echo "local u2up_NET_EXTERNAL_MAC_ADDR=$mac" >> ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp
		else
			echo "local u2up_NET_EXTERNAL_MAC_ADDR=" >> ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp
		fi
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}
	rv=$?
	return $rv
}

save_u2up_net_internal_iface_selection() {
	local rv=0
	local ifname=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	cat ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE} | grep -v "u2up_NET_INTERNAL_IFNAME=" > ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp
	if [ -n "$ifname" ]; then
		if [ "$ifname" != "none" ]; then
			echo "local u2up_NET_INTERNAL_IFNAME=$ifname" >> ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp
		else
			echo "local u2up_NET_INTERNAL_IFNAME=" >> ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp
		fi
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}
	rv=$?
	return $rv
}

save_u2up_net_internal_mac_selection() {
	local rv=0
	local mac=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	cat ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE} | grep -v "u2up_NET_INTERNAL_MAC_ADDR=" > ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp
	if [ -n "$mac" ]; then
		if [ "$mac" != "-" ]; then
			echo "local u2up_NET_INTERNAL_MAC_ADDR=$mac" >> ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp
		else
			echo "local u2up_NET_INTERNAL_MAC_ADDR=" >> ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp
		fi
	else
		return 1
	fi
	mv ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}
	rv=$?
	return $rv
}

save_u2up_target_hostname_selection() {
	local rv=1
	local var_target_hostname_set=""
	local var_target_hostname_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"Hostname")
		var_target_hostname_set=u2up_TARGET_HOSTNAME
		var_target_hostname_current=target_hostname_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE} | grep -v "${var_target_hostname_set}=" > ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}_tmp
	echo "local ${var_target_hostname_set}=$value" >> ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}
	rv=$?
	echo "${var_target_hostname_current}=${value}"
	return $rv
}

save_u2up_target_admin_selection() {
	local rv=1
	local var_target_admin_name_set=""
	local var_target_admin_name_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"Admin name")
		var_target_admin_name_set=u2up_TARGET_ADMIN_NAME
		var_target_admin_name_current=target_admin_name_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE} | grep -v "${var_target_admin_name_set}=" > ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}_tmp
	echo "local ${var_target_admin_name_set}=$value" >> ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}_tmp ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}
	rv=$?
	echo "${var_target_admin_name_current}=${value}"
	return $rv
}

save_u2up_net_external_config_selection() {
	local rv=1
	local var_net_config_set=""
	local var_net_config_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"MAC address")
		var_net_config_set=u2up_NET_EXTERNAL_MAC_ADDR
		var_net_config_current=net_external_mac_addr_current
		;;
	"IP address/mask")
		var_net_config_set=u2up_NET_EXTERNAL_ADDR_MASK
		var_net_config_current=net_external_addr_mask_current
		;;
	"IP gateway")
		var_net_config_set=u2up_NET_EXTERNAL_GW
		var_net_config_current=net_external_gw_current
		;;
	"DNS1")
		var_net_config_set=u2up_NET_EXTERNAL_DNS1
		var_net_config_current=net_external_dns1_current
		;;
	"DNS2")
		var_net_config_set=u2up_NET_EXTERNAL_DNS2
		var_net_config_current=net_external_dns2_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE} | grep -v "${var_net_config_set}=" > ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp
	echo "local ${var_net_config_set}=$value" >> ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}_tmp ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}
	rv=$?
	echo "${var_net_config_current}=${value}"
	return $rv
}

save_u2up_net_internal_config_selection() {
	local rv=1
	local var_net_config_set=""
	local var_net_config_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"MAC address")
		var_net_config_set=u2up_NET_INTERNAL_MAC_ADDR
		var_net_config_current=net_internal_mac_addr_current
		;;
	"IP address/mask")
		var_net_config_set=u2up_NET_INTERNAL_ADDR_MASK
		var_net_config_current=net_internal_addr_mask_current
		;;
	"IP gateway")
		var_net_config_set=u2up_NET_INTERNAL_GW
		var_net_config_current=net_internal_gw_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE} | grep -v "${var_net_config_set}=" > ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp
	echo "local ${var_net_config_set}=$value" >> ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}_tmp ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}
	rv=$?
	echo "${var_net_config_current}=${value}"
	return $rv
}

save_u2up_install_repo_selection() {
	local rv=1
	local var_install_repo_set=""
	local var_install_repo_current=""
	local conf_dir=${1}
	shift
	local value="$(echo $@ | sed 's/[^:]*://' | sed 's/ *//')"
	local name="$(echo $@ | sed 's/RENAMED //' | sed 's/:.*//')"

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "${value}" ] || [ "x${name}" = "x${value}" ]; then
		return 0
	fi
	case $name in
	"Base URL")
		var_install_repo_set=u2up_INSTALL_REPO_BASE_URL
		var_install_repo_current=install_repo_base_url_current
		;;
	*)
		return 1;
	esac

	cat ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE} | grep -v "${var_install_repo_set}=" > ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}_tmp
	echo "local ${var_install_repo_set}=$value" >> ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}_tmp
	mv ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}_tmp ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}
	rv=$?
	echo "${var_install_repo_current}=${value}"
	return $rv
}

#############################################
#                                           #
# ENABLE functions for U2UP configurations! #
#                                           #
#############################################
#
# Enable U2UP configured target keymap.
# (called from installers and chrooted during installation / upgrade)	
# (TODO: locale settings)
#
enable_u2up_keymap_selection() {
	local rv=1
	local conf_dir=${1:-${U2UP_CONF_DIR}}

	if [ ! -f "${conf_dir}/${U2UP_KEYMAP_CONF_FILE}" ]; then
		return 1
	fi
	source ${conf_dir}/${U2UP_KEYMAP_CONF_FILE}
#	if [ -n "$u2up_KEYMAP" ] && [ $TARGET_DONE -eq 0 ]; then
	if [ -n "$u2up_KEYMAP" ]; then
		loadkeys $u2up_KEYMAP
		rv=$?
		if [ $rv -eq 0 ]; then
#			echo "KEYMAP=$u2up_KEYMAP" > /etc/vconsole.conf
			systemd-firstboot --keymap=$u2up_KEYMAP
			rv=$?
#			set_target_done_for ${conf_dir}/${U2UP_KEYMAP_CONF_FILE} ${new_target_done}
#			rv=$?
		fi
	fi
	return $rv
}

#
# Enable U2UP configured target hostname.
# (called only chrooted during installation / upgrade)	
#
enable_u2up_target_hostname_selection() {
	local rv=1
	local conf_dir=${1:-${U2UP_CONF_DIR}}

	if [ ! -f "${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}" ]; then
		return 1
	fi
	source ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}
#	if [ -n "$u2up_TARGET_HOSTNAME" ] && [ $TARGET_DONE -eq 0 ]; then
	if [ -n "$u2up_TARGET_HOSTNAME" ]; then
#		hostnamectl set-hostname $u2up_TARGET_HOSTNAME
#		systemd-firstboot --hostname=$u2up_TARGET_HOSTNAME
		echo "${u2up_TARGET_HOSTNAME}" > /etc/hostname
		rv=$?
#		if [ $rv -eq 0 ]; then
#			set_target_done_for ${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE} ${new_target_done}
#			rv=$?
#		fi
	fi
	return $rv
}

#
# Enable U2UP configured target administrator.
# (called only chrooted during installation / upgrade)	
#
enable_u2up_target_admin_selection() {
	local rv=1
	local conf_dir=${1:-${U2UP_CONF_DIR}}

	if [ ! -f "${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}" ]; then
		return 1
	fi
	source ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}
#	if [ -n "$u2up_TARGET_ADMIN_NAME" ] && [ $TARGET_DONE -eq 0 ]; then
	if [ -n "$u2up_TARGET_ADMIN_NAME" ]; then
		useradd -m -c "Admin User" $u2up_TARGET_ADMIN_NAME
		rv=$?
		if [ $rv -ne 0 ] && [ $rv -ne 9 ]; then
			return 1
		fi
		systemd-sysusers
		rv=$?
		if [ $rv -ne 0 ]; then
			return 1
		fi
		passwd -de $u2up_TARGET_ADMIN_NAME
		rv=$?
		if [ $rv -ne 0 ]; then
			return 1
		fi
		usermod -aG wheel $u2up_TARGET_ADMIN_NAME
		rv=$?
		if [ $rv -ne 0 ]; then
			return 1
		fi
		# Locking the root account and scrambling its password!
		passwd -l root
		rv=$?
		if [ $rv -ne 0 ]; then
			return 1
		fi
		usermod -p '!' root
		rv=$?
#		if [ $rv -eq 0 ]; then
#			set_target_done_for ${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE} ${new_target_done}
#			rv=$?
#		fi
	fi
	return $rv
}

#
#TO BE DELETED!
#
#OLD_enable_u2up_net_config_selection() {
#	local rv=0
#	local u2up_NET_INTERNAL_IFNAME=""
#	local u2up_NET_INTERNAL_ADDR_MASK=""
#	local u2up_NET_INTERNAL_GW=""
#	local u2up_NET_DNS=""
#	local u2up_NET_DOMAINS=""
#	local TARGET_DONE=0
#	local new_target_done=${1:-0}
#	local conf_dir=${1:-${U2UP_CONF_DIR}}
#
#	if [ ! -f "${conf_dir}/${U2UP_NETWORK_CONF_FILE}" ]; then
#		return 1
#	fi
#	source ${conf_dir}/${U2UP_NETWORK_CONF_FILE}
#	if [ $TARGET_DONE -eq 0 ]; then
#		if [ -n "${u2up_NET_INTERNAL_IFNAME}" ] && [ -n "${u2up_NET_INTERNAL_ADDR_MASK}" ] && [ -n "${u2up_NET_INTERNAL_GW}" ]; then
#			nmcli con add type ethernet con-name internal ifname ${u2up_NET_INTERNAL_IFNAME} ip4 ${u2up_NET_INTERNAL_ADDR_MASK} gw4 ${u2up_NET_INTERNAL_GW}
#			rv=$?
#			if [ $rv -eq 0 ]; then
#				nmcli con mod internal connection.zone trusted
#				rv=$?
#			fi
#		fi
#		if [ $rv -eq 0 ] && [ -n "${u2up_NET_DNS}" ]; then
#			nmcli con mod internal ipv4.dns "${u2up_NET_DNS}"
#			nmcli con mod internal ipv4.dns "127.0.0.1"
#			rv=$?
#		fi
#		if [ $rv -eq 0 ]; then
#			set_target_done_for ${conf_dir}/${U2UP_NETWORK_CONF_FILE} ${new_target_done}
#			rv=$?
#		fi
#	fi
#	return $rv
#}

#
# Enable U2UP configured external networking.
# (called from installers and chrooted during installation / upgrade)
#
enable_u2up_net_external_config_selection() {
	local net_external_addr=""
	local net_uuid=""
	local conf_dir=${1:-${U2UP_CONF_DIR}}
	local msg=""
	local rv=0

	if [ $rv -eq 0 ] && [ ! -f "${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}" ]; then
		msg="Missing static external network configuration!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		source ${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}
		if \
			[ -z "$u2up_NET_EXTERNAL_IFNAME" ] || \
			[ -z "$u2up_NET_EXTERNAL_ADDR_MASK" ] || \
			[ -z "$u2up_NET_EXTERNAL_GW" ] || \
			[ -z "$u2up_NET_EXTERNAL_DNS1" ];
		then
			msg="Incomplete static external network configuration!"
			rv=1
		else
			net_external_addr=$(echo -n "${u2up_NET_EXTERNAL_ADDR_MASK}" | sed 's|\/.*||g')
		fi
	fi
	if [ $rv -eq 0 ]; then
		net_uuid=$(uuidgen)
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Unable to generate new UUID for external network configuration!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		cat > /etc/NetworkManager/system-connections/external.nmconnection << EOF
[connection]
id=external
uuid=${net_uuid}
type=ethernet
interface-name=${u2up_NET_EXTERNAL_IFNAME}
permissions=
zone=external

[ethernet]
mac-address-blacklist=

[ipv4]
address1=${u2up_NET_EXTERNAL_ADDR_MASK},${u2up_NET_EXTERNAL_GW}
dns=127.0.0.1;
dns-search=
method=manual

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto
EOF
#method=ignore
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to write \"NetworkManager\" static external network configuration!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		chmod 600 /etc/NetworkManager/system-connections/external.nmconnection
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to set file permissions for \"NetworkManager\" static external network configuration!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		cat > /etc/systemd/network/10-external-static.network << EOF
[Match]
Name=${u2up_NET_EXTERNAL_IFNAME}

EOF
		if [ -n "${u2up_NET_EXTERNAL_MAC_ADDR}" ]; then
			cat >> /etc/systemd/network/10-external-static.network << EOF
[Link]
MACAddress=${u2up_NET_EXTERNAL_MAC_ADDR}

EOF
		fi
		cat >> /etc/systemd/network/10-external-static.network << EOF
[Network]
Address=${u2up_NET_EXTERNAL_ADDR_MASK}
Gateway=${u2up_NET_EXTERNAL_GW}
DNS=127.0.0.1
EOF
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to write \"systemd\" static external network configuration!"
		fi
	fi
#	if [ $rv -eq 0 ]; then
#		chmod 600 /etc/systemd/network/10-external-static.network
#		rv=$?
#		if [ $rv -ne 0 ]; then
#			msg="Failed to set file permissions for \"systemd\" static external network configuration!"
#		fi
#	fi
	if [ $rv -eq 0 ]; then
		echo "Disabling \"systemd-networked\" of the installed system (in-favour of NetworkManager)..." >&2
		if [ -f "/etc/systemd/system/network-online.target.wants/systemd-networkd-wait-online.service" ]; then
			rm -f /etc/systemd/system/network-online.target.wants/systemd-networkd-wait-online.service
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to remove systemd-networkd-wait-online.service!"
			fi
		fi
		if [ $rv -eq 0 ] && [ -f "/etc/systemd/system/dbus-org.freedesktop.network1.service" ]; then
			rm -f /etc/systemd/system/dbus-org.freedesktop.network1.service
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to remove dbus-org.freedesktop.network1.service!"
			fi
		fi
		if [ $rv -eq 0 ] && [ -f "/etc/systemd/system/multi-user.target.wants/systemd-networkd.service" ]; then
			rm -f /etc/systemd/system/multi-user.target.wants/systemd-networkd.service
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to remove systemd-networkd.service!"
			fi
		fi
		if [ $rv -eq 0 ] && [ -f "/etc/systemd/system/sockets.target.wants/systemd-networkd.socket" ]; then
			rm -f /etc/systemd/system/sockets.target.wants/systemd-networkd.socket
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to remove systemd-networkd.socket!"
			fi
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Disabling \"systemd-resolved\" of the installed system (in-favour of dnsmasq)..." >&2
		if [ -f "/etc/systemd/system/multi-user.target.wants/systemd-resolved.service" ]; then
			rm -f /etc/systemd/system/multi-user.target.wants/systemd-resolved.service
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to remove systemd-resolved.service!"
			fi
		fi
		if [ $rv -eq 0 ] && [ -f "/etc/systemd/system/dbus-org.freedesktop.resolve1.service" ]; then
			rm -f /etc/systemd/system/dbus-org.freedesktop.resolve1.service
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to remove dbus-org.freedesktop.resolve1.service!"
			fi
		fi
		if [ $rv -eq 0 ]; then
			if [ -f "/etc/resolv.conf_orig" ]; then
				rm -f /etc/resolv.conf
				rv=$?
				if [ $rv -ne 0 ]; then
					msg="Failed to remove old resolv.conf!"
				fi
			else
				mv /etc/resolv.conf /etc/resolv.conf_orig
				rv=$?
				if [ $rv -ne 0 ]; then
					msg="Failed to move original resolv.conf!"
				fi
			fi
		fi
#		if [ $rv -eq 0 ]; then
#			cat > /etc/resolv.conf << EOF
#nameserver 127.0.0.1
#EOF
#			rv=$?
#			if [ $rv -ne 0 ]; then
#				msg="Failed to write static resolv.conf!"
#			fi
#		fi
#		if [ $rv -eq 0 ]; then
#			if [ -f "/etc/dnsmasq.conf_orig" ]; then
#				rm -f /etc/dnsmasq.conf
#				rv=$?
#				if [ $rv -ne 0 ]; then
#					msg="Failed to remove old dnsmasq.conf!"
#				fi
#			else
#				mv /etc/dnsmasq.conf /etc/dnsmasq.conf_orig
#				rv=$?
#				if [ $rv -ne 0 ]; then
#					msg="Failed to move original dnsmasq.conf!"
#				fi
#			fi
#		fi
#		if [ $rv -eq 0 ]; then
#			cat > /etc/dnsmasq.conf << EOF
##/etc/dnsmasq.conf
#domain-needed
#bogus-priv
#no-resolv
#
#domain=local.net
#expand-hosts
#local=/local.net/
#
#listen-address=127.0.0.1
#listen-address=${net_internal_addr}
#bind-interfaces
#
#conf-dir=/etc/dnsmasq.d,*.conf
#EOF
#			rv=$?
#			if [ $rv -ne 0 ]; then
#				msg="Failed to write common dnsmasq.conf!"
#			fi
#		fi
		if [ $rv -eq 0 ]; then
			cat > /etc/dnsmasq.d/10-servers.conf << EOF
#/etc/dnsmasq.d/10-servers.conf
server=${u2up_NET_EXTERNAL_DNS1}
EOF
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to write dnsmasq.d/10-servers.conf!"
			fi
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Enabling \"IPv4 forwarding\"..." >&2
		if [ -f "/etc/sysctl.conf" ]; then
			sed -i 's|.*net.ipv4.ip_forward=.*|net.ipv4.ip_forward=1|' /etc/sysctl.conf
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to enable \"IPv4 forwarding\"!"
			fi
		fi
	fi
	if [ $rv -ne 0 ]; then
		echo "${msg}" >&2
	fi
	return $rv
}

#OLD: execute_net_reconfiguration() {
#
# Enable U2UP configured internal networking.
# (called from installers and chrooted during installation / upgrade)
#
enable_u2up_net_internal_config_selection() {
	local net_internal_addr=""
	local net_uuid=""
	local conf_dir=${1:-${U2UP_CONF_DIR}}
	local msg=""
	local rv=0

	if [ $rv -eq 0 ] && [ ! -f "${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}" ]; then
		msg="Missing static internal network configuration!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		source ${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}
		if \
			[ -z "$u2up_NET_INTERNAL_IFNAME" ] || \
			[ -z "$u2up_NET_INTERNAL_ADDR_MASK" ] || \
			[ -z "$u2up_NET_INTERNAL_GW" ];
		then
			msg="Incomplete static internal network configuration!"
			rv=1
		else
			net_internal_addr=$(echo -n "${u2up_NET_INTERNAL_ADDR_MASK}" | sed 's|\/.*||g')
		fi
	fi
	if [ $rv -eq 0 ]; then
		net_uuid=$(uuidgen)
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Unable to generate new UUID for internal network configuration!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		cat > /etc/NetworkManager/system-connections/internal.nmconnection << EOF
[connection]
id=internal
uuid=${net_uuid}
type=ethernet
interface-name=${u2up_NET_INTERNAL_IFNAME}
permissions=
zone=trusted

[ethernet]
mac-address-blacklist=

[ipv4]
address1=${u2up_NET_INTERNAL_ADDR_MASK},${u2up_NET_INTERNAL_GW}
dns=127.0.0.1;
dns-search=
method=manual

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto
EOF
#method=ignore
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to write \"NetworkManager\" static internal network configuration!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		chmod 600 /etc/NetworkManager/system-connections/internal.nmconnection
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to set file permissions for \"NetworkManager\" static internal network configuration!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		cat > /etc/systemd/network/10-internal-static.network << EOF
[Match]
Name=${u2up_NET_INTERNAL_IFNAME}

EOF
		if [ -n "${u2up_NET_INTERNAL_MAC_ADDR}" ]; then
			cat >> /etc/systemd/network/10-internal-static.network << EOF
[Link]
MACAddress=${u2up_NET_INTERNAL_MAC_ADDR}

EOF
		fi
		cat >> /etc/systemd/network/10-internal-static.network << EOF
[Network]
Address=${u2up_NET_INTERNAL_ADDR_MASK}
Gateway=${u2up_NET_INTERNAL_GW}
DNS=127.0.0.1
EOF
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to write \"systemd\" static internal network configuration!"
		fi
	fi
#	if [ $rv -eq 0 ]; then
#		chmod 600 /etc/systemd/network/10-internal-static.network
#		rv=$?
#		if [ $rv -ne 0 ]; then
#			msg="Failed to set file permissions for \"systemd\" static internal network configuration!"
#		fi
#	fi
#	if [ $rv -eq 0 ]; then
#		echo "Disabling \"systemd-resolved\" of the installed system (in-favour of dnsmasq)..." >&2
#		if [ -f "/etc/systemd/system/multi-user.target.wants/systemd-resolved.service" ]; then
#			rm -f /etc/systemd/system/multi-user.target.wants/systemd-resolved.service
#			rv=$?
#			if [ $rv -ne 0 ]; then
#				msg="Failed to remove systemd-resolved.service!"
#			fi
#		fi
#		if [ $rv -eq 0 ] && [ -f "/etc/systemd/system/dbus-org.freedesktop.resolve1.service" ]; then
#			rm -f /etc/systemd/system/dbus-org.freedesktop.resolve1.service
#			rv=$?
#			if [ $rv -ne 0 ]; then
#				msg="Failed to remove dbus-org.freedesktop.resolve1.service!"
#			fi
#		fi
#		if [ $rv -eq 0 ]; then
#			if [ -f "/etc/resolv.conf_orig" ]; then
#				rm -f /etc/resolv.conf
#				rv=$?
#				if [ $rv -ne 0 ]; then
#					msg="Failed to remove old resolv.conf!"
#				fi
#			else
#				mv /etc/resolv.conf /etc/resolv.conf_orig
#				rv=$?
#				if [ $rv -ne 0 ]; then
#					msg="Failed to move original resolv.conf!"
#				fi
#			fi
#		fi
#		if [ $rv -eq 0 ]; then
#			cat > /etc/resolv.conf << EOF
#nameserver 127.0.0.1
#EOF
#			rv=$?
#			if [ $rv -ne 0 ]; then
#				msg="Failed to write static resolv.conf!"
#			fi
#		fi
		if [ $rv -eq 0 ]; then
			if [ -f "/etc/dnsmasq.conf_orig" ]; then
				rm -f /etc/dnsmasq.conf
				rv=$?
				if [ $rv -ne 0 ]; then
					msg="Failed to remove old dnsmasq.conf!"
				fi
			else
				mv /etc/dnsmasq.conf /etc/dnsmasq.conf_orig
				rv=$?
				if [ $rv -ne 0 ]; then
					msg="Failed to move original dnsmasq.conf!"
				fi
			fi
		fi
		if [ $rv -eq 0 ]; then
			cat > /etc/dnsmasq.conf << EOF
#/etc/dnsmasq.conf
domain-needed
bogus-priv
no-resolv

domain=local.net
expand-hosts
local=/local.net/

listen-address=127.0.0.1
listen-address=${net_internal_addr}
bind-interfaces

conf-dir=/etc/dnsmasq.d,*.conf
EOF
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to write common dnsmasq.conf!"
			fi
		fi
#		if [ $rv -eq 0 ]; then
#			cat > /etc/dnsmasq.d/10-servers.conf << EOF
##/etc/dnsmasq.d/10-servers.conf
#server=${u2up_NET_INTERNAL_GW}
#EOF
#			rv=$?
#			if [ $rv -ne 0 ]; then
#				msg="Failed to write dnsmasq.d/10-servers.conf!"
#			fi
#		fi
#	fi
	if [ $rv -ne 0 ]; then
		echo "${msg}" >&2
	fi
	return $rv
}

#
# Enable U2UP additional services.
# (called only chrooted during installation / upgrade)
#
enable_u2up_additional_services() {
	local msg=""
	local rv=0

	if [ $rv -eq 0 ]; then
		echo "Prepare \"apache2\" webserver data path..." >&2
		mkdir -p /srv/www
		rv=$?
		cp -a ${U2UP_TMP_SRV_DIR}/www/* /srv/www/
		(( rv+=$? ))
		chown -R daemon.daemon /srv/www
		(( rv+=$? ))
		if [ $rv -ne 0 ]; then
			msg="Failed to prepare \"apache2\" webserver data path!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Prepare configuration for \"apache2\" webserver..." >&2
		cat >> /etc/apache2/httpd.conf << EOF

DocumentRoot "//srv/www/html"
<Directory "//srv/www/html">
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
</Directory>

# Security Hardening Begin:
TraceEnable off
ServerSignature Off
ServerTokens Prod
#SSLProtocol -ALL +TLSv1.2
#SSLCipherSuite ALL:!aNULL:!ADH:!eNULL:!LOW:!EXP:RC4+RSA:+HIGH:+MEDIUM
<Directory />
Options None
Order allow,deny
Allow from all
</Directory>
# Security Hardening End!

EOF
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to write apache2/httpd.conf!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Enabling \"apache2\" webserver..." >&2
		systemctl enable apache2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to enable \"apache2\" webserver!"
		else
			echo "Successfully enabled \"apache2\" webserver!" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Prepare \"postfix\" mail-server virtual mailbox owner (user \"vmail\")..." >&2
		groupmod -g 5000 vmail
		(( rv+=$? ))
		usermod -d /srv/vmail -g 5000 -u 5000 -s /bin/bash vmail
		(( rv+=$? ))
		chown -R vmail.vmail /var/spool/vmail
		(( rv+=$? ))
		if [ $rv -ne 0 ]; then
			msg="Failed to prepare \"postfix\" mail-server virtual mailbox owner!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Prepare \"postfix\" mail-server virtual mailbox path..." >&2
		mkdir -p /srv/vmail
		rv=$?
		cp -a ${U2UP_TMP_SRV_DIR}/vmail/* /srv/vmail/
		(( rv+=$? ))
		chown -R vmail.vmail /srv/vmail
		(( rv+=$? ))
		if [ $rv -ne 0 ]; then
			msg="Failed to prepare \"postfix\" mail-server virtual mailbox path!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Prepare specific \"postfix\" mail-server virtual configuration..." >&2
		mkdir -p /srv/etc/postfix
		rv=$?
		cp -a ${U2UP_TMP_SRV_DIR}/etc/postfix/* /srv/etc/postfix/
		(( rv+=$? ))
		touch /srv/etc/postfix/vhosts
		(( rv+=$? ))
		touch /srv/etc/postfix/vmaps
		(( rv+=$? ))
		postmap /srv/etc/postfix/vmaps
		(( rv+=$? ))
		if [ $rv -ne 0 ]; then
			msg="Failed to prepare specific \"postfix\" mail-server virtual configuration!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Prepare common configuration for \"postfix\" mail-server..." >&2
		cp -p /etc/postfix/main.cf /etc/postfix/main.cf_orig
		(( rv+=$? ))
		cat > /etc/postfix/main.cf << EOF
compatibility_level=2
smtputf8_enable = no

biff = no

# appending .domain is the MUA's job.
append_dot_mydomain = no

# Uncomment the next line to generate "delayed mail" warnings
#delay_warning_time = 4h

myhostname = localhost
alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
myorigin = \$myhostname
mynetworks = 127.0.0.1/8
inet_interfaces = 127.0.0.1

mailbox_size_limit = 0
virtual_mailbox_domains = /srv/etc/postfix/vhosts
virtual_mailbox_maps = hash:/srv/etc/postfix/vmaps
virtual_mailbox_base = /srv/vmail
virtual_minimum_uid = 1000
virtual_uid_maps = static:5000
virtual_gid_maps = static:5000
recipient_delimiter = +
EOF
		(( rv+=$? ))
		if [ $rv -ne 0 ]; then
			msg="Failed to write common postfix/main.cf!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Enabling \"postfix\" mail-server..." >&2
		systemctl enable postfix
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to enable \"postfix\" mail-server!"
		else
			echo "Successfully enabled \"postfix\" mail-server!" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Prepare specific \"dovecot\" imap-server configuration..." >&2
		mkdir -p /srv/etc/dovecot
		rv=$?
		cp -a ${U2UP_TMP_SRV_DIR}/etc/dovecot/* /srv/etc/dovecot/
		(( rv+=$? ))
		if [ $rv -ne 0 ]; then
			msg="Failed to prepare specific \"dovecot\" imap-server configuration!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Prepare common configuration for \"dovecot\" imap-server..." >&2
		cat > /etc/dovecot/dovecot.conf << EOF
auth_mechanisms = plain cram-md5
auth_verbose = yes
base_dir = /var/run/dovecot/
info_log_path = /var/log/dovecot.info
log_path = /var/log/dovecot
log_timestamp = "%Y-%m-%d %H:%M:%S "
mail_location = maildir:/srv/vmail/%d/%n
passdb {
  args = /srv/etc/dovecot/passwd
  driver = passwd-file
}
protocols = imap
service auth {
  executable = /usr/libexec/dovecot/auth
  user = root
}
service imap-login {
  chroot = login
  executable = /usr/libexec/dovecot/imap-login
  user = dovecot
}
service imap {
  executable = /usr/libexec/dovecot/imap
}
ssl = no
userdb {
  args = /srv/etc/dovecot/users
  driver = passwd-file
}
valid_chroot_dirs = /var/spool/vmail
EOF
		(( rv+=$? ))
		if [ $rv -ne 0 ]; then
			msg="Failed to write common dovecot/dovecot.conf!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Enabling \"dovecot\" imap-server..." >&2
		systemctl enable dovecot.socket
		(( rv+=$? ))
		systemctl enable dovecot.service
		(( rv+=$? ))
		if [ $rv -ne 0 ]; then
			msg="Failed to enable \"dovecot\" imap-server!"
		else
			echo "Successfully enabled \"dovecot\" imap-server!" >&2
		fi
	fi
	if [ $rv -ne 0 ]; then
		echo "${msg}" >&2
	fi

	return $rv
}

#
# Enable U2UP configured SW packages repository.
# (called from "upgrade" installer and chrooted during installation / upgrade)
#
enable_u2up_install_repo_selection() {
	local rv=0
	local conf_dir=${1:-${U2UP_CONF_DIR}}

	if [ ! -f "${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}" ]; then
		return 1
	fi
	source ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}
#	if [ $TARGET_DONE -eq 0 ]; then
		if [ -n "${u2up_INSTALL_REPO_BASE_URL}" ]; then
			mkdir -p /etc/yum.repos.d
			(( rv+=$? ))
			echo "[base-repo]" > /etc/yum.repos.d/base.repo
			(( rv+=$? ))
			echo "name=Base installation repository" >> /etc/yum.repos.d/base.repo
			(( rv+=$? ))
			echo "baseurl=${u2up_INSTALL_REPO_BASE_URL}" >> /etc/yum.repos.d/base.repo
			(( rv+=$? ))
			echo "enabled=1" >> /etc/yum.repos.d/base.repo
			(( rv+=$? ))
			echo "metadata_expire=0" >> /etc/yum.repos.d/base.repo
			(( rv+=$? ))
			echo "gpgcheck=0" >> /etc/yum.repos.d/base.repo
			(( rv+=$? ))
#			set_target_done_for ${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE} ${new_target_done}
#			rv=$?
		else
			rm -rf /etc/yum.repos.d
			rv=$?
		fi
#	fi
	return $rv
}

############################################################
#                                                          #
# MISC functions of the U2UP configuration / installation! #
#                                                          #
############################################################
#
# Prepare a new set of U2UP configuration files to be used
# in upgrade.
# (called only from "upgrade" installer)
#
prepare_u2up_upgrade_configuration() {
	local rv=0
	local conf_dir=$1
	local upgrade_disk_part

	if [ -z "${conf_dir}" ]; then
		return 1
	fi
	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ ! -e "${conf_dir}/${U2UP_KEYMAP_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_KEYMAP_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_TARGET_DISK_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
		source ${conf_dir}/${U2UP_TARGET_DISK_CONF_FILE}
		case ${u2up_TARGET_PART} in
		${u2up_TARGET_DISK}3)
			upgrade_disk_part=4
			;;
		${u2up_TARGET_DISK}4)
			upgrade_disk_part=3
			;;
		esac
		save_u2up_target_part_selection ${u2up_TARGET_DISK}${upgrade_disk_part} ${conf_dir}
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_TARGET_HOSTNAME_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_TARGET_HOSTNAME_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_TARGET_ADMIN_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_TARGET_ADMIN_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_NETWORK_EXTERNAL_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_NETWORK_EXTERNAL_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_NETWORK_INTERNAL_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_NETWORK_INTERNAL_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	if [ ! -e "${conf_dir}/${U2UP_INSTALL_REPO_CONF_FILE}" ]; then
		cp -pf ${U2UP_CONF_DIR}/${U2UP_INSTALL_REPO_CONF_FILE} ${conf_dir}/
		(( rv+=$? ))
	fi
	return $rv
}

#
# Check and/or create U2UP defined filesystems.
# New rootfs partition is allways re-created!
# (called from installers - never chrooted)
check_create_filesystems() {
	local u2up_TARGET_DISK=$1
	local u2up_TARGET_PART=$2
	local fstype=""
	local msg=""
	local rv=0

	if [ $rv -eq 0 ] && [ -z "$u2up_TARGET_DISK" ]; then
		msg="Target disk not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$u2up_TARGET_PART" ]; then
		msg="Target disk paritition not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		# Installation partition:
		echo "Allways re-create EXT4 filesystem on installation partition /dev/$u2up_TARGET_PART:" >&2
		umount -f $U2UP_INSTALL_ROOT_MNT >&2
		mkfs.ext4 -F /dev/$u2up_TARGET_PART >&2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to re-create EXT4 filesystem on installation partition /dev/$u2up_TARGET_PART!"
#		else
#			echo -e "OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		# Boot partition:
		echo "Check / re-create VFAT filesystem on \"boot\" partition /dev/${u2up_TARGET_DISK}1:" >&2
		fstype="$(lsblk -fr /dev/${u2up_TARGET_DISK}1 | grep -v "NAME" | sed 's/[a-z,0-9]* //' | sed 's/ .*//')"
		if [ -z "$fstype" ] || [ "$fstype" != "vfat" ]; then
#			echo "Recreate:" >&2
			mkfs.vfat -F /dev/${u2up_TARGET_DISK}1 >&2
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to check / re-create VFAT filesystem on \"boot\" partition /dev/${u2up_TARGET_DISK}1!"
#			else
#				echo -e "Re-create OK!\n" >&2
			fi
#		else
#			echo -e "Check OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		# Log partition:
		echo "Check / re-create EXT4 filesystem on \"log\" partition /dev/${u2up_TARGET_DISK}2:" >&2
		fstype="$(lsblk -fr /dev/${u2up_TARGET_DISK}2 | grep -v "NAME" | sed 's/[a-z,0-9]* //' | sed 's/ .*//')"
		if [ -z "$fstype" ] || [ "$fstype" != "ext4" ]; then
#			echo "Recreate:" >&2
			mkfs.ext4 -F /dev/${u2up_TARGET_DISK}2 >&2
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to check / re-create EXT4 filesystem on \"log\" partition /dev/${u2up_TARGET_DISK}2!"
#			else
#				echo -e "Re-create OK!\n" >&2
			fi
#		else
#			echo -e "Check OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		# RootA partition:
		echo "Check / re-create EXT4 filesystem on \"rootA\" partition /dev/${u2up_TARGET_DISK}3:" >&2
		fstype="$(lsblk -fr /dev/${u2up_TARGET_DISK}3 | grep -v "NAME" | sed 's/[a-z,0-9]* //' | sed 's/ .*//')"
		if [ -z "$fstype" ] || [ "$fstype" != "ext4" ]; then
#			echo "Recreate:" >&2
			mkfs.ext4 -F /dev/${u2up_TARGET_DISK}3 >&2
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to check / re-create EXT4 filesystem on \"rootA\" partition /dev/${u2up_TARGET_DISK}3!"
#			else
#				echo -e "Re-create OK!\n" >&2
			fi
#		else
#			echo -e "Check OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		# RootB partition:
		echo "Check / re-create EXT4 filesystem on \"rootB\" partition /dev/${u2up_TARGET_DISK}4:" >&2
		fstype="$(lsblk -fr /dev/${u2up_TARGET_DISK}4 | grep -v "NAME" | sed 's/[a-z,0-9]* //' | sed 's/ .*//')"
		if [ -z "$fstype" ] || [ "$fstype" != "ext4" ]; then
#			echo "Recreate:" >&2
			mkfs.ext4 -F /dev/${u2up_TARGET_DISK}4 >&2
			rv=$?
			if [ $rv -ne 0 ]; then
				msg="Failed to check / re-create EXT4 filesystem on \"rootB\" partition /dev/${u2up_TARGET_DISK}4!"
#			else
#				echo -e "Re-create OK!\n" >&2
			fi
#		else
#			echo -e "Check OK!\n" >&2
		fi
	fi
	if [ $rv -eq 0 ]; then
		msg="Checking / re-creating filesystems successfully finished!"
	fi

	echo "${msg}" >&2
	return $rv
}

#
# Initial check of the images bundle for the correctness of checksum, rootfs and
# date-timestamp IDs presence.
# (called from installers - never chrooted)
#
check_images_bundle_initial_content() {
	local msg=""
	local rv=0

	cd ${U2UP_IMAGES_DIR} >&2
	ln -sf ${U2UP_IMAGES_BUNDLE_ARCHIVE} $(cat ${U2UP_IMAGES_BUNDLE_ARCHIVE_SUM} | sed -e 's%^.* %%g')
	sha256sum -c ${U2UP_IMAGES_BUNDLE_ARCHIVE_SUM}
	rv=$?
	if [ $rv -ne 0 ]; then
		msg="Images bundle checksum mismatch!"
	fi
	cd - >&2
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_IDS_CONF_FILE} > /dev/null
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_IDS_CONF_FILE}!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		U2UP_IMAGE_ROOTFS_NAME=$(tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IDS_CONF_FILE} 2> /dev/null | grep "^local u2up_ROOTFS_NAME" | sed 's/^.*u2up_ROOTFS_NAME\=//')
		if [ -z "${U2UP_IMAGE_ROOTFS_NAME}" ]; then
			msg="Images bundle installation rootfs archive name not set!"
			rv=1
		fi
	fi
	if [ $rv -eq 0 ]; then
		U2UP_IMAGE_ROOTFS_DATETIME=$(tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IDS_CONF_FILE} 2> /dev/null | grep "^local u2up_ROOTFS_DATETIME" | sed 's/^.*u2up_ROOTFS_DATETIME\=//')
		if [ -z "${U2UP_IMAGE_ROOTFS_DATETIME}" ]; then
			msg="Images bundle installation rootfs archive Date-TimeStamp not set!"
			rv=1
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz!"
		fi
	fi
	if [ $rv -ne 0 ]; then
		U2UP_IMAGE_ROOTFS_NAME=""
		U2UP_IMAGE_ROOTFS_DATETIME=""
		echo "${msg}" >&2
	fi
	return $rv
}

#
# Mount target partition before extracting "rootfs".
# (called from installers before calling chroot)
#
mount_installation_filesystem() {
	local u2up_TARGET_DISK=$1
	local u2up_TARGET_PART=$2
	local root_part_suffix=$3
	local msg=""
	local rv=0

	echo "Mounting installation partition filesystem..." >&2
	if [ $rv -eq 0 ] && [ -z "$u2up_TARGET_DISK" ]; then
		msg="Target disk not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$u2up_TARGET_PART" ]; then
		msg="Target disk paritition not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$root_part_suffix" ]; then
		msg="Target root_part_suffix not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		umount -f $U2UP_INSTALL_ROOT_MNT >&2
		mkdir -p $U2UP_INSTALL_ROOT_MNT >&2
		mount /dev/$u2up_TARGET_PART $U2UP_INSTALL_ROOT_MNT >&2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount installation partition filesystem (${u2up_TARGET_PART} - root${root_part_suffix})!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		msg="Mounting installation partition filesystem (${u2up_TARGET_PART} - root${root_part_suffix}) successfully finished!"
	fi

	echo "${msg}" >&2
	return $rv
}

#
# Extract just "rootfs" from images bundle to the target partition.
# (called from installers before calling chroot)
#
extract_rootfs_from_images_bundle() {
	local u2up_TARGET_DISK=$1
	local u2up_TARGET_PART=$2
	local root_part_suffix=$3
	local msg=""
	local rv=0

	echo "Extracting root filesystem archive..." >&2
	if [ $rv -eq 0 ] && [ -z "$u2up_TARGET_DISK" ]; then
		msg="Target disk not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$u2up_TARGET_PART" ]; then
		msg="Target disk paritition not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ] && [ -z "$root_part_suffix" ]; then
		msg="Target root_part_suffix not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz | tar xz -C $U2UP_INSTALL_ROOT_MNT >&2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to extract root filesystem archive!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		msg="Extracting root filesystem archive successfully finished!"
	fi

	echo "${msg}" >&2
	return $rv
}

#
# Prepare / call chroot with target update script.
# (called from installer scripts)
#
update_filesystem_chrooted() {
	local msg=""
	local rv=0

	echo "Updating installed system (chrooted)..." >&2
	if [ $rv -eq 0 ]; then
		mount -o bind /dev ${U2UP_INSTALL_ROOT_MNT}/dev
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /dev!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		mount -o bind /dev/shm ${U2UP_INSTALL_ROOT_MNT}/dev/shm
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /dev/shm!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		mount -o bind /proc ${U2UP_INSTALL_ROOT_MNT}/proc
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /proc!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		mount -o bind /sys ${U2UP_INSTALL_ROOT_MNT}/sys
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /sys!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		umount ${U2UP_INSTALL_ROOT_MNT}/${U2UP_TMP_SRV_DIR} >&2
		mkdir -p ${U2UP_INSTALL_ROOT_MNT}/${U2UP_TMP_SRV_DIR} >&2
		mount -o bind /srv ${U2UP_INSTALL_ROOT_MNT}/${U2UP_TMP_SRV_DIR}
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to mount-bind /srv!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		if [ -x "${HOME}/u2up-update-chrooted.sh" ]; then
			echo "WARNING! Using local (chrooted) script!" >&2
			cp -pf ${U2UP_INSTALL_ROOT_MNT}/usr/bin/u2up-update-chrooted.sh ${U2UP_INSTALL_ROOT_MNT}/usr/bin/u2up-update-chrooted.sh_orig
			cp -f ${HOME}/u2up-update-chrooted.sh ${U2UP_INSTALL_ROOT_MNT}/usr/bin/u2up-update-chrooted.sh
		fi
		if [ -f "${HOME}/u2up-install-bash-lib" ]; then
			echo "WARNING! Using local (bash-lib) script!" >&2
			cp -pf ${U2UP_INSTALL_ROOT_MNT}/lib/u2up/u2up-install-bash-lib ${U2UP_INSTALL_ROOT_MNT}/lib/u2up/u2up-install-bash-lib_orig
			cp -f ${HOME}/u2up-install-bash-lib ${U2UP_INSTALL_ROOT_MNT}/lib/u2up/u2up-install-bash-lib
		fi
		chroot ${U2UP_INSTALL_ROOT_MNT} /usr/bin/u2up-update-chrooted.sh
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed executing (chrooted) script!"
		fi
	fi
	umount ${U2UP_INSTALL_ROOT_MNT}${U2UP_TMP_SRV_DIR}
	umount ${U2UP_INSTALL_ROOT_MNT}/sys
	umount ${U2UP_INSTALL_ROOT_MNT}/proc
	umount ${U2UP_INSTALL_ROOT_MNT}/dev/shm
	umount ${U2UP_INSTALL_ROOT_MNT}/dev
	# Mounted explicitly in chrooted env but unmounted here!
	umount ${U2UP_INSTALL_ROOT_MNT}${U2UP_TMP_BOOT_DIR}
	umount ${U2UP_INSTALL_ROOT_MNT}/var/volatile/log
	if [ $rv -ne 0 ]; then
		echo "${msg}" >&2
		echo "Failed to update installation system (chrooted)!" >&2
	else
		echo "Successfully updated installation system (chrooted)!" >&2
	fi

	return $rv 
}

#
# Checks all content of the images bundle beside correctness of the bundle
# checksum.
# (called only chrooted)
#
check_images_bundle_all_content() {
	local msg=""
	local rv=0

	if [ -f "${U2UP_IMAGES_LOCAL_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE}" ]; then
		mv ${U2UP_IMAGES_LOCAL_DIR}/* ${U2UP_IMAGES_DIR}/
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to move local images bundle to common location!"
		fi
	fi
	if [ $rv -eq 0 ] && [ ! -f "${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE}" ]; then
		msg="Images bundle not available!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		cd ${U2UP_IMAGES_DIR} >&2
		ln -sf ${U2UP_IMAGES_BUNDLE_ARCHIVE} $(cat ${U2UP_IMAGES_BUNDLE_ARCHIVE_SUM} | sed -e 's%^.* %%g')
		sha256sum -c ${U2UP_IMAGES_BUNDLE_ARCHIVE_SUM}
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle checksum mismatch!"
		fi
		cd - >&2
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_IDS_CONF_FILE} 2> /dev/null
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_IDS_CONF_FILE}!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		U2UP_IMAGE_ROOTFS_NAME=$(tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IDS_CONF_FILE} 2> /dev/null | grep "^local u2up_ROOTFS_NAME" | sed 's/^.*u2up_ROOTFS_NAME\=//')
		if [ -z "${U2UP_IMAGE_ROOTFS_NAME}" ]; then
			msg="Images bundle installation rootfs archive name not set!"
			rv=1
		fi
	fi
	if [ $rv -eq 0 ]; then
		U2UP_IMAGE_ROOTFS_DATETIME=$(tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} -O ${U2UP_IDS_CONF_FILE} 2> /dev/null | grep "^local u2up_ROOTFS_DATETIME" | sed 's/^.*u2up_ROOTFS_DATETIME\=//')
		if [ -z "${U2UP_IMAGE_ROOTFS_DATETIME}" ]; then
			msg="Images bundle installation rootfs archive Date-TimeStamp not set!"
			rv=1
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_IMAGE_ROOTFS_NAME}-${MACHINE}.tar.gz!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_KERNEL_IMAGE}-${MACHINE}.bin
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_KERNEL_IMAGE}-${MACHINE}.bin!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} ${U2UP_INITRD_IMAGE}.cpio
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Images bundle not containing: ${U2UP_INITRD_IMAGE}.cpio!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		tar tvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} systemd-${U2UP_EFI_FALLBACK_IMAGE}
		rv=$?
		if [ $rv -ne 0 ]; then
			masg="Images bundle not containing: systemd-${U2UP_EFI_FALLBACK_IMAGE}!"
		fi
	fi
	if [ $rv -ne 0 ]; then
		U2UP_IMAGE_ROOTFS_NAME=""
		U2UP_IMAGE_ROOTFS_DATETIME=""
		echo "${msg}" >&2
	fi
	return $rv
}

#
# Extracts remaining content (beside rootfs) from the images bundle.
# (called only chrooted)
#
extract_remaining_from_images_bundle() {
	local root_part_suffix=$1
	local msg=""
	local rv=0

	if [ $rv -eq 0 ] && [ -z "$root_part_suffix" ]; then
		msg="Target root_part_suffix not defined!"
		rv=1
	fi
	if [ $rv -eq 0 ]; then
		echo "Extracting U2UP_IDS..." >&2
		tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} --overwrite -C ${U2UP_CONF_DIR} ${U2UP_IDS_CONF_FILE} >&2
		rv=$?
		if [ $rv -ne 0 ]; then
			msg="Failed to extract U2UP_IDS!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		echo "Extracting installation boot images..." >&2
		mkdir -p ${U2UP_TMP_BOOT_DIR}/EFI/BOOT
		mkdir -p ${U2UP_TMP_BOOT_DIR}/loader/entries
		tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} --no-same-owner --no-same-permissions -C ${U2UP_TMP_BOOT_DIR} ${U2UP_KERNEL_IMAGE}-${MACHINE}.bin >&2
		((rv+=$?))
		mv ${U2UP_TMP_BOOT_DIR}/${U2UP_KERNEL_IMAGE}-${MACHINE}.bin ${U2UP_TMP_BOOT_DIR}/bzImage${root_part_suffix} >&2
		((rv+=$?))
		tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} --no-same-owner --no-same-permissions -C ${U2UP_TMP_BOOT_DIR} ${U2UP_INITRD_IMAGE}.cpio >&2
		((rv+=$?))
		mv ${U2UP_TMP_BOOT_DIR}/${U2UP_INITRD_IMAGE}.cpio ${U2UP_TMP_BOOT_DIR}/microcode${root_part_suffix}.cpio >&2
		((rv+=$?))
		if [ ! -f "${U2UP_TMP_BOOT_DIR}/EFI/BOOT/bootx64.efi" ]; then
			tar xvf ${U2UP_IMAGES_DIR}/${U2UP_IMAGES_BUNDLE_ARCHIVE} --no-same-owner --no-same-permissions -C ${U2UP_TMP_BOOT_DIR}/EFI/BOOT systemd-${U2UP_EFI_FALLBACK_IMAGE} >&2
			((rv+=$?))
			mv ${U2UP_TMP_BOOT_DIR}/EFI/BOOT/systemd-${U2UP_EFI_FALLBACK_IMAGE} ${U2UP_TMP_BOOT_DIR}/EFI/BOOT/${U2UP_EFI_FALLBACK_IMAGE} >&2
			((rv+=$?))
		fi
		if [ $rv -ne 0 ]; then
			msg="Failed to extract installation boot images!"
		fi
	fi
	if [ $rv -eq 0 ]; then
		msg="Extracting installation images successfully finished!"
	fi

	echo "${msg}" >&2
	return $rv
}

#
# Transfer new U2UP images bundle archive to the mounted target
# filesystem before calling "chroot"!
# (called from "first install" installer only)
# ("upgrade" installer shares the bundle via common partition)
#
populate_u2up_images_bundle() {
	local root_path_prefix=${1:-${U2UP_INSTALL_ROOT_MNT}}
	local images_dir=${2:-${U2UP_IMAGES_DIR}}
	local images_name=${3:-${U2UP_IMAGES_BUNDLE_NAME}}
	local rv=0

	if [ ! -d "${images_dir}" ]; then
		return 1
	fi
	if [ -z "$root_path_prefix" ]; then
		return 1
	fi
	rm -rf ${root_path_prefix}${images_dir}
	mkdir -p ${root_path_prefix}${images_dir}
	cp -pf ${images_dir}/${images_name}* ${root_path_prefix}${images_dir}/
	rv=$?
	return $rv
}

#
# Transfer new U2UP configuration files to the mounted target
# filesystem before calling "chroot"!
# (called from "first install" and "upgrade" installers)
#
populate_u2up_configurations() {
	local root_path_prefix=$1
	local conf_dir=${2:-${U2UP_CONF_DIR}}
	local file=""
	local rv=0

	if [ ! -d "${conf_dir}" ]; then
		return 1
	fi
	if [ -z "$root_path_prefix" ]; then
		return 1
	fi
	rm -rf ${root_path_prefix}${U2UP_CONF_DIR}
	mkdir -p $(dirname ${root_path_prefix}${U2UP_CONF_DIR})
	cp -a ${conf_dir} ${root_path_prefix}${U2UP_CONF_DIR}
	rv=$?
#	if [ $rv -eq 0 ]; then
#		for file in $(ls ${root_path_prefix}${U2UP_CONF_DIR}); do
#			set_target_done_for ${root_path_prefix}${U2UP_CONF_DIR}/${file} 0
#			rv=$?
#		done
#	fi
	return $rv
}

#
# Finalize configuration during the first boot.
# (used in "u2up-pre-config.sh")
# (OBSOLETE)
#
evaluate_u2up_configurations() {
#set -x
	local file=""
	local rv=0
	if [ ! -d "${U2UP_CONF_DIR}" ]; then
		return 1
	fi
	for file in $(ls ${U2UP_CONF_DIR}); do
		case $file in
		${U2UP_KEYMAP_CONF_FILE})
#			enable_u2up_keymap_selection
#			rv=$?
			;;
		${U2UP_TARGET_DISK_CONF_FILE})
			;;
		${U2UP_TARGET_HOSTNAME_CONF_FILE})
#			enable_u2up_target_hostname_selection
#			rv=$?
			;;
		${U2UP_TARGET_ADMIN_CONF_FILE})
#			enable_u2up_target_admin_selection
#			rv=$?
			;;
		${U2UP_NETWORK_EXTERNAL_CONF_FILE})
#			enable_u2up_net_external_config_selection
#			rv=$?
			;;
		${U2UP_NETWORK_INTERNAL_CONF_FILE})
#			enable_u2up_net_internal_config_selection
#			rv=$?
			;;
		${U2UP_INSTALL_REPO_CONF_FILE})
#			enable_u2up_install_repo_selection
#			rv=$?
			;;
		esac
	done
	return $rv
}

